<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Particle Test</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Share+Tech&display=swap" rel="stylesheet">
        <script src="https://unpkg.com/gpu.js@2.16.0/dist/gpu-browser.min.js"></script> <!-- gpu acceleration -->
    </head>
    <body>
        <style>
            body {
                background-color: #222;
                margin: auto;
                height: 100%;
                overflow: hidden;
                cursor: none;
            }

            .share-tech-regular {
                font-family: "Share Tech", sans-serif;
                font-weight: 400;
                font-style: normal;
            }
        </style>
        <canvas id="gameScreen" width="1800" height="1000"></canvas>
        <p id="fps">60</p>
        <script>
            //canvas or gamescreen
            var canvas = document.getElementById("gameScreen");
            //context, for drawing
            var ctx = canvas.getContext("2d");

            var gl = canvas.getContext("webgl");

            //settings canvas size and scale
            var screenScale = window.innerWidth / canvas.width
            if (window.innerHeight / canvas.height < screenScale)
                screenScale = window.innerHeight / canvas.height;

            var stop = false;
            var frameCount = 0;
            var fps, fpsInterval, startTime, now, then, elapsed;
            function startAnimating(fps) {
                fpsInterval = 1000 / fps;
                then = Date.now();
                startTime = then;
                animate();
            }
            function animate() {
                requestAnimationFrame(animate)
                now = Date.now();
                elapsed = now - then;
                if (elapsed > fpsInterval) {
                    then = now - (elapsed % fpsInterval);
                    tickloop();
                }
            }
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            ctx.translate(window.innerWidth/2,window.innerHeight/2);

            ctx.scale(screenScale, screenScale);

            var filterStrength = 10;
            //used  to be 20
            var frameTime = 0, lastLoop = new Date, thisLoop;
            var fpsOut = document.getElementById('fps');

            // Report the fps only every second, to only lightly affect measurements
            setInterval(function() {
                fpsOut.innerHTML = (1000 / frameTime).toFixed(1);
                game.fps = Math.max(30, Number(fpsOut.innerHTML));
            }, 1000);

            const keys = [];
            let keyBuffer = [];

            //detect keypresses
            window.addEventListener('keydown', function(e) {
                if (!e.repeat) {
                    const key = e.key.toLowerCase();
                    if (!keys.includes(key))
                        keys.push(key);
                }

                if (e.key.toLowerCase() == "r") randomizeForces();
            }, false);
            window.addEventListener('keyup', function(e) {
                const key = e.key.toLowerCase();
                while (keys.includes(key)) {
                    keys.splice(keys.indexOf(key), 1);
                }
            }, false);

            ctx.lineWidth = 3;

            const gpu = new GPU.GPU();

            function randomizeForces() {
                refererences.forEach((reference) => reference.forEach((force,i) => reference[i] = -1.5 + Math.random()*3))
            }

            let refererences = [
                [    1,   1 ],
                [   -1,   1 ]
            ];

            let refererenceColors = [ "#955", "#995", "#595", "#599", "#559", "#959" ];

// ----------------------------------------------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------------------------------------------

            const game = {
                fps: 60,
                tick: 0,
                drawSize: 10,
                particleAlpha: 0.5,
                particleSize: 10,
                particleRange: 150,
                forceMultiplier: 0.001,
                collisionForce: 0.01,
                dispersalForce: 0.1,
                takeOver: false
            }

            switch("snake") {
                case "clump": {
                    refererences = [
                        [    1 ]
                    ]

                    break;
                }
                case "disperse": {
                    refererences = [
                        [   -1 ]
                    ]

                    break;
                }
                case "redrule": {
                    refererences = [
                        [  1.5, 0.3, 0.3, 0.3, 0.3, 0.3 ],
                        [  0.5,   1, 0.3, 0.3, 0.3, 0.3 ],
                        [   -1,-0.3,   1, 0.3, 0.3, 0.3 ],
                        [   -1,-0.3,-0.3,   1, 0.3, 0.3 ],
                        [   -1,-0.3,-0.3,-0.3,   1, 0.3 ],
                        [   -1,-0.3,-0.3,-0.3,-0.3,   1 ]
                    ]
                    refererenceColors = [ "#c55", "#cc5", "#5c5", "#5cc", "#55c", "#c5c" ];

                    break;
                }
                case "pyramid": {
                    refererences = [
                        [    1, 0.5, 0.5, 0.5, 0.5, 0.5 ],
                        [ -0.3,   1, 0.5, 0.5, 0.5, 0.5 ],
                        [ -0.3,-0.3,   1, 0.5, 0.5, 0.5 ],
                        [ -0.3,-0.3,-0.3,   1, 0.5, 0.5 ],
                        [ -0.3,-0.3,-0.3,-0.3,   1, 0.5 ],
                        [ -0.3,-0.3,-0.3,-0.3,-0.3,   1 ]
                    ]
                    refererenceColors = [ "#c55", "#cc5", "#5c5", "#5cc", "#55c", "#c5c" ];

                    break;
                }
                case "snake": {
                    refererences = [
                        [  0.5,   1,-0.2,-0.2,-0.2,-0.2 ],
                        [ -0.2, 0.5,   1,-0.2,-0.2,-0.2 ],
                        [ -0.2,-0.2, 0.5,   1,-0.2,-0.2 ],
                        [ -0.2,-0.2,-0.2, 0.5,   1,-0.2 ],
                        [ -0.2,-0.2,-0.2,-0.2, 0.5,   1 ],
                        [    1,-0.2,-0.2,-0.2,-0.2, 0.5 ]
                    ]

                    //game.particleRange = 400;

                    break;
                }
                case "circles": {
                    refererences = [
                        [    1,   0],
                        [    1,  -1],
                    ]

                    break;
                }
                case "test1": {
                    refererences = [
                        [   1,-0.5],
                        [   1,   1],
                    ]

                    refererenceColors = [ "#ccc", "#111" ];

                    break;
                }
            }

            const particles = [];
            for (var i = 0; i < 5000; i++) {
                particles.push( [ -800+Math.random()*1600, -400+Math.random()*800, 0, 0, Math.floor(refererences.length*Math.random()) ] );
            }

            const particleStats = [ 
                particles.length, 
                refererences, 
                game.drawSize,
                game.particleAlpha,
                game.particleSize,
                game.particleRange,
                game.forceMultiplier,
                game.collisionForce,
                game.dispersalForce
            ]

// ----------------------------------------------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------------------------------------------

            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            // round particles, reduces performance
            if (true) {
                ctx.lineCap = 'round';
                game.roundLines = true;
            }

            const renderParticles = gpu.createKernel(function(particles, particleStats, refererences) {
                let i = this.thread.x;
                let x = particles[i][0];
                let y = particles[i][1];
                let vx = particles[i][2];
                let vy = particles[i][3];
                let referenceIndex = particles[i][4];

                let x2 = 0;
                let y2 = 0;
                let vx2 = 0;
                let vy2 = 0;
                let referenceIndex2 = 0;
                
                /*if (Math.abs(x) > 850) {
                    x = Math.sign(x)*850;
                    vx = -Math.sign(x)*1000*particleStats[6];
                }
                if (Math.abs(y) > 450) {
                    y = Math.sign(y)*450;
                    vy = -Math.sign(y)*1000*particleStats[6];
                }*/
                
                if (Math.abs(x) > 850) {
                    x -= Math.sign(x)*1700;
                    vx *= 0.9;
                }
                if (Math.abs(y) > 450) {
                    y -= Math.sign(y)*900;
                    vy *= 0.9;
                }
                
                for (let i2 = 0; i2 < particleStats[0]; i2++) if (i != i2) {
                    x2 = particles[i2][0];
                    y2 = particles[i2][1];
                    vx2 = particles[i2][2];
                    vy2 = particles[i2][3];
                    referenceIndex2 = particles[i2][4];
                    
                    const dist = [ x2 - x, y2 - y, 0 ];
                    dist[2] = Math.sqrt(dist[0]*dist[0] + dist[1]*dist[1]);

                    let hitSize = particleStats[4];
                    if (referenceIndex != referenceIndex2) hitSize *= 2;

                    if (dist[2] > 0) if (dist[2] < hitSize) {
                        dist[0] /= dist[2];
                        dist[1] /= dist[2];

                        // collision code formula because nothing is original in the programming industry
                        const velChange = particleStats[8];// + particleStats[7] * (vx*dist[0] + vy*dist[1] - vx2*dist[0] - vy2*dist[1]);
                        let collisionForce = (hitSize-dist[2])/hitSize;

                        vx -= (vx-vx2) * particleStats[7] + velChange*dist[0]*collisionForce*collisionForce;
                        vy -= (vy-vy2) * particleStats[7] + velChange*dist[1]*collisionForce*collisionForce;
                    } else if (dist[2] < particleStats[5]) {

                        const forceAmount = particleStats[6] * ( ( particleStats[5] - dist[2] ) / particleStats[5]) / dist[2];

                        dist[0] *= forceAmount;
                        dist[1] *= forceAmount;

                        vx += dist[0] * ( refererences[referenceIndex][referenceIndex2] );
                        vy += dist[1] * ( refererences[referenceIndex][referenceIndex2] );
                    }
                }

                x += vx;
                y += vy;
                
                return [ x, y, vx, vy + referenceIndex*1000 ];
            }, {
                output: [particles.length],
                dynamicArguments: true
            })

            // uses "startanimating" instead of setInterval on firefox (does not work well with setinterval)
            if (false) if(navigator.userAgent.toLowerCase().includes("firefox"))
                startAnimating(60);
            else setInterval( () => { tickloop() }, 16.66);

            ctx.fillStyle = "#200000"; // 50
            ctx.fillRect(850, -450, -1700, 900);

            ctx.lineWidth = game.drawSize;
            ctx.globalAlpha = game.particleAlpha;

            if (false) renderParticles(particles, particleStats).forEach((particle, i) => {
                ctx.beginPath();
                if (game.roundLines){
                    ctx.moveTo(particle[0], particle[1]);
                    ctx.lineTo(particle[0], particle[1]);
                }
                else {
                    ctx.moveTo(particle[0], particle[1]-game.drawSize/2);
                    ctx.lineTo(particle[0], particle[1]+game.drawSize/2);
                }
                ctx.strokeStyle = "#999";//refererences[particle[4]].color;
                ctx.stroke();
            })

            ctx.globalAlpha = 1;

            tickloop();

            function tickloop() {
                game.tick++;
                if (game.tick > 200) game.tick -= 600;
                //check frameRate
                var thisFrameTime = (thisLoop = new Date) - lastLoop;
                frameTime += (thisFrameTime - frameTime) / filterStrength;
                lastLoop = thisLoop;

                ctx.fillStyle = "#00000090"; // 50
                ctx.fillRect(850, -450, -1700, 900);

                ctx.lineWidth = game.drawSize;
                ctx.globalAlpha = game.particleAlpha;

                renderParticles(particles, particleStats, refererences).forEach((particle, i) => {
                    ctx.beginPath();
                    if (game.roundLines){
                        ctx.moveTo(particle[0], particle[1]);
                        ctx.lineTo(particle[0], particle[1]);
                    }
                    else {
                        ctx.moveTo(particle[0], particle[1]-game.drawSize/2);
                        ctx.lineTo(particle[0], particle[1]+game.drawSize/2);
                    }
                    const referenceIndex = Math.round(particle[3]/1000);
                    ctx.strokeStyle = refererenceColors[referenceIndex];
                    ctx.stroke();

                    //let vy = particle[3]%1000;
                    //if (Math.abs(vy) > 900) vy -= Math.sign(vy)*1000;

                    particles[i] = [particle[0], particle[1], particle[2], particle[3]-referenceIndex*1000, referenceIndex];
                })

                ctx.globalAlpha = 1;
                
                ctx.fillStyle = "#000";
                ctx.rect(-2500, -1750, 5000, 3500);
                ctx.rect(850, -450, -1700, 900);
                ctx.fill();

                ctx.fillStyle = "#555";
                ctx.font = "30px share tech";
                ctx.fillText(game.fps,0,-485);

                requestAnimationFrame(tickloop);
            }
       </script>
    </body>
</html>
