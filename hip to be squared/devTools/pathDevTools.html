<!DOCTYPE html>
<head>
    <title>HtbS Image maker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dongle&display=swap" rel="stylesheet">
</head>
<body>
    <style>
        body {
            color: #000000;
            margin: auto;
            height: 100%;
            overflow: hidden;
            cursor: none;
        }
        .share-tech-regular {
            font-family: "Share Tech", sans-serif;
            font-weight: 400;
            font-style: normal;
        }
    </style>
    <canvas oncontextmenu="return false;" onmousemove="xy(event)" width="1500px" height="1000px" id="gameScreen"></canvas>
    <p id="fps">60</p>
    <script>function xy(event) {  }</script>
    <script>
        function startAnimating(fps) {
            fpsInterval = 1000 / fps;
            then = Date.now();
            startTime = then;
            animate();
        }

        // the animation loop calculates time elapsed since the last loop
        // and only draws if your specified fps interval is achieved

        function animate() {
            requestAnimationFrame(animate);
            now = Date.now();
            elapsed = now - then;
            if (elapsed > fpsInterval) {
                then = now - (elapsed % fpsInterval);
                tickloop();
            }
        }
        //canvas or gamescreen
        var canvas = document.getElementById("gameScreen");
        //context, for drawing
        var ctx = canvas.getContext("2d");
        //settings canvas size and scale
        var screenScale = window.innerWidth/1800;
        if (window.innerHeight/1000 < screenScale) screenScale = window.innerHeight/1000;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.translate(window.innerWidth/2, window.innerHeight/2);

        ctx.scale(screenScale, screenScale);

        ctx.lineWidth = 3;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'left';
        ctx.lineJoin = "bevel";

        //resizing
        window.addEventListener("resize", (  ) => {
            ctx.resetTransform();

            //settings canvas size and scale
            screenScale = window.innerWidth/1800;
            if (window.innerHeight/1000 < screenScale) screenScale = window.innerHeight/1000;

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            ctx.translate(window.innerWidth/2, window.innerHeight/2);

            ctx.scale(screenScale, screenScale);

            ctx.lineWidth = 3;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';
            ctx.lineJoin = "bevel";

            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.fillRect(-1800,-1000,3600,2000);
        });

        const keys = {};
        const mouse = { x: 0, y: 0, gridx: 0, gridy: 0 };

        let path = [];

        const grid = 25;

        let arcPoint = false;

        //detect keypresses
        window.addEventListener('keydown', async function (e) {
            keys[e.key.toLowerCase()] = true;

            if (e.key.toLowerCase() == " ") console.log("`" + JSON.stringify(path) + "`");
            if (e.key.toLowerCase() == "a" && !arcPoint) arcPoint = [ mouse.gridx, mouse.gridy ];
            else if (e.key.toLowerCase() == "a" && !!arcPoint) arcPoint = false;
            if (e.key.toLowerCase() == "f") path.push( { type: "fill", r:100, g:100, b:100 } );
            if (e.key.toLowerCase() == "s") path.push( { type: "stroke", r:50, g:50, b:50 } );
            if (e.key.toLowerCase() == "c") path.push( { type: "close" } );
            if (e.key.toLowerCase() == "z") path.splice( path.length-1 );
        }, false);
        window.addEventListener('keyup', function (e) {
            keys[e.key.toLowerCase()] = false;
        }, false)/[ ];
        window.addEventListener('mousedown', function () {
            keys.mouse = true;
            mouse.down = true;

            if (Math.abs(mouse.x) < 300 && Math.abs(mouse.y) < 300) {
                path.push( { type: "point", x: mouse.gridx, y: mouse.gridy, move: keys.shift } );

                if (arcPoint) arcPoint[2] = Math.hypot(arcPoint[0]-path[path.length-1].x,arcPoint[1]-path[path.length-1].y);
            }
        }, false);
        window.addEventListener('mouseup', function () {
            keys.mouse = false;
            mouse.down = false;
        }, false);
        function xy(e) {
            mouse.x = e.x/screenScale - (window.innerWidth-1800*screenScale)/2/screenScale -900;
            mouse.y = e.y/screenScale - (window.innerHeight-1000*screenScale)/2/screenScale -500;

            if (arcPoint) if (arcPoint[2]) {
                const ratio = arcPoint[2]/Math.hypot(mouse.x-arcPoint[0],mouse.y-arcPoint[1]);
                mouse.gridx = Math.round((arcPoint[0]+(mouse.x-arcPoint[0])*ratio)/grid*2)*grid/2;
                mouse.gridy = Math.round((arcPoint[1]+(mouse.y-arcPoint[1])*ratio)/grid*2)*grid/2;
                return;
            }
            
            mouse.gridx = Math.round(mouse.x/grid*2)*grid/2;
            mouse.gridy = Math.round(mouse.y/grid*2)*grid/2;
        }

        function tickloop() {
            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.strokeStyle = "#fff";
            ctx.fillRect(-1800,-1000,3600,2000);
            ctx.strokeRect(-900,-500,1800,1000);

            ctx.beginPath();
            ctx.fillStyle = "#fff";
            ctx.font = "30px share tech";
            ctx.fillText("z: deleteLast", -800,-430);
            ctx.fillText("f: fill", -800,-400);
            ctx.fillText("s: stroke", -800,-370);
            ctx.fillText("c: closepath", -800,-340);
            ctx.fillText("a: arcPoint", -800,-310);

            ctx.strokeStyle = "#555";
            ctx.strokeRect(-250,-250,500,500);

            let colorCount = 0;
            ctx.beginPath();
            ctx.lineWidth = 10;
            var lastPoint = false;
            var lastMovePoint = false;
            path.forEach((item, i) => {
                switch(item.type) {
                    case "point": {
                        if (item.move) {
                            ctx.moveTo(item.x,item.y);
                            lastMovePoint = [item.x,item.y];
                        } else ctx.lineTo(item.x,item.y);
                        
                        lastPoint = [item.x,item.y];
                        if (!lastMovePoint) lastMovePoint = lastPoint;
                        break;
                    }
                    case "fill": {
                        ctx.fillStyle = "rgb("+item.r+","+item.g+","+item.b+")";
                        ctx.fill();
                        break;
                    }
                    case "stroke": {
                        ctx.strokeStyle = "rgb("+item.r+","+item.g+","+item.b+")";
                        ctx.stroke();
                        ctx.beginPath();
                        lastPoint = false;
                        lastMovePoint = false;
                        break;
                    }
                    case "close": {
                        ctx.closePath();
                        lastPoint = lastMovePoint;
                        break;
                    }
                }
            })
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#666";
            ctx.stroke();
            
            ctx.lineWidth = 3;

            path.forEach((item) => {
                if (item.type == "fill" || item.type == "stroke") {
                    ctx.save();
                    ctx.translate(0,colorCount*175)

                    ctx.beginPath();
                    ctx.fillStyle = "#555";
                    ctx.fillRect(300,-450,500,150);

                    ctx.beginPath();
                    ctx.moveTo(320,-430);
                    ctx.lineTo(720,-430);
                    ctx.moveTo(320+item.r/255*400,-440);
                    ctx.lineTo(320+item.r/255*400,-420);
                    ctx.strokeStyle = "#f99";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(320,-375);
                    ctx.lineTo(720,-375);
                    ctx.moveTo(320+item.g/255*400,-385);
                    ctx.lineTo(320+item.g/255*400,-365);
                    ctx.strokeStyle = "#9f9";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(320,-320);
                    ctx.lineTo(720,-320);
                    ctx.moveTo(320+item.b/255*400,-330);
                    ctx.lineTo(320+item.b/255*400,-310);
                    ctx.strokeStyle = "#aaf";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.fillStyle = "#f99";
                    ctx.font = "30px share tech"
                    ctx.fillText(item.r, 730, -430);

                    ctx.beginPath();
                    ctx.fillStyle = "#9f9";
                    ctx.font = "30px share tech"
                    ctx.fillText(item.g, 730, -375);

                    ctx.beginPath();
                    ctx.fillStyle = "#aaf";
                    ctx.font = "30px share tech"
                    ctx.fillText(item.b, 730, -320);

                    if (mouse.down && mouse.x > 300) {
                        if (Math.abs(-430+175*colorCount-mouse.y) < 25) item.r = Math.round(Math.max(0,Math.min(255,(mouse.x-320)/400*255))/5)*5;
                        if (Math.abs(-375+175*colorCount-mouse.y) < 25) item.g = Math.round(Math.max(0,Math.min(255,(mouse.x-320)/400*255))/5)*5;
                        if (Math.abs(-320+175*colorCount-mouse.y) < 25) item.b = Math.round(Math.max(0,Math.min(255,(mouse.x-320)/400*255))/5)*5;
                    }
                    
                    colorCount++;

                    ctx.restore();
                }
            })

            ctx.beginPath();
            ctx.moveTo(250,250);
            ctx.lineTo(-250,-250);
            ctx.moveTo(250,-250);
            ctx.lineTo(-250,250);
            for (var i = -250+grid; i < 250; i += grid) {
                ctx.moveTo(-250,i);
                ctx.lineTo(250,i);
                ctx.moveTo(i,-250);
                ctx.lineTo(i,250);
            }
            ctx.strokeStyle = "#cccccc22";
            ctx.stroke();

            ctx.strokeStyle = "#555";
            ctx.strokeRect(-250/2.5,-250/2.5,500/2.5,500/2.5);

            if (lastPoint && !keys.shift) {
                ctx.beginPath();
                ctx.moveTo(...lastPoint);
                ctx.lineTo(mouse.gridx, mouse.gridy)
                ctx.strokeStyle = "#ccc";
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(mouse.x+5,mouse.y+5);
            ctx.lineTo(mouse.x+30,mouse.y+20);
            ctx.lineTo(mouse.x+20,mouse.y+30);
            ctx.closePath();
            ctx.rect(mouse.gridx, mouse.gridy-2.5, 5, 5);
            ctx.fillStyle = "#ccc";
            ctx.fill();
        }

        function input(input) {
            path = JSON.parse(input);
        }

        setInterval( tickloop, 1000/60 );
    </script>
</body>