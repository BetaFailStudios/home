<!DOCTYPE html>
<head>
    <title>HtbS Image maker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dongle&display=swap" rel="stylesheet">
</head>
<body>
    <style>
        body {
            color: #000000;
            margin: auto;
            height: 100%;
            overflow: hidden;
            cursor: none;
        }
        .share-tech-regular {
            font-family: "Share Tech", sans-serif;
            font-weight: 400;
            font-style: normal;
        }
    </style>
    <canvas oncontextmenu="return false;" onmousemove="xy(event)" width="1500px" height="1000px" id="gameScreen"></canvas>
    <p id="fps">60</p>
    <script>function xy(event) {  }</script>
    <script>
        function startAnimating(fps) {
            fpsInterval = 1000 / fps;
            then = Date.now();
            startTime = then;
            animate();
        }

        // the animation loop calculates time elapsed since the last loop
        // and only draws if your specified fps interval is achieved

        function animate() {
            requestAnimationFrame(animate);
            now = Date.now();
            elapsed = now - then;
            if (elapsed > fpsInterval) {
                then = now - (elapsed % fpsInterval);
                tickloop();
            }
        }
        //canvas or gamescreen
        var canvas = document.getElementById("gameScreen");
        //context, for drawing
        var ctx = canvas.getContext("2d");
        //settings canvas size and scale
        var screenScale = window.innerWidth/1800;
        if (window.innerHeight/1000 < screenScale) screenScale = window.innerHeight/1000;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.translate(window.innerWidth/2, window.innerHeight/2);

        ctx.scale(screenScale, screenScale);

        ctx.lineWidth = 3;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'left';
        ctx.lineJoin = "bevel";

        //resizing
        window.addEventListener("resize", (  ) => {
            ctx.resetTransform();

            //settings canvas size and scale
            screenScale = window.innerWidth/1800;
            if (window.innerHeight/1000 < screenScale) screenScale = window.innerHeight/1000;

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            ctx.translate(window.innerWidth/2, window.innerHeight/2);

            ctx.scale(screenScale, screenScale);

            ctx.lineWidth = 3;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';
            ctx.lineJoin = "bevel";

            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.fillRect(-1800,-1000,3600,2000);
        });

        const keys = {};
        const mouse = { x: 0, y: 0, gridx: 0, gridy: 0 };

        let blocks = [];

        const grid = 25;

        let arcPoint = false;

        //detect keypresses
        window.addEventListener('keydown', async function (e) {
            keys[e.key.toLowerCase()] = true;

            if (e.key.toLowerCase() == " ") console.log("`" + JSON.stringify(blocks) + "`");
            if (e.key.toLowerCase() == "z") blocks.splice( blocks.length-1 );
        }, false);
        window.addEventListener('keyup', function (e) {
            keys[e.key.toLowerCase()] = false;
        }, false)/[ ];
        window.addEventListener('mousedown', function () {
            keys.mouse = true;
            mouse.down = true;

            mouse.startPoint = [mouse.gridx,mouse.gridy];
        }, false);
        window.addEventListener('mouseup', function () {
            keys.mouse = false;
            mouse.down = false;

            if (!mouse.startPoint) return;

            const xy = [Math.min(mouse.gridx, mouse.startPoint[0]),Math.min(mouse.gridy, mouse.startPoint[1])]

            blocks.push([...xy, Math.abs(mouse.startPoint[0]-mouse.gridx), Math.abs(mouse.startPoint[1]-mouse.gridy)]);

            if (!blocks[blocks.length-1][2] || !blocks[blocks.length-1][3]) blocks.splice(blocks.length-1,1);

            mouse.startPoint = false;
        }, false);
        function xy(e) {
            mouse.x = e.x/screenScale - (window.innerWidth-1800*screenScale)/2/screenScale -900;
            mouse.y = e.y/screenScale - (window.innerHeight-1000*screenScale)/2/screenScale -500;

            if (arcPoint) if (arcPoint[2]) {
                const ratio = arcPoint[2]/Math.hypot(mouse.x-arcPoint[0],mouse.y-arcPoint[1]);
                mouse.gridx = Math.round((arcPoint[0]+(mouse.x-arcPoint[0])*ratio)/grid)*grid;
                mouse.gridy = Math.round((arcPoint[1]+(mouse.y-arcPoint[1])*ratio)/grid)*grid;
                return;
            }
            
            mouse.gridx = Math.round(mouse.x/grid)*grid;
            mouse.gridy = Math.round(mouse.y/grid)*grid;
        }

        function tickloop() {
            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.strokeStyle = "#fff";
            ctx.fillRect(-1800,-1000,3600,2000);
            ctx.strokeRect(-900,-500,1800,1000);

            ctx.beginPath();
            ctx.fillStyle = "#fff";
            ctx.font = "30px share tech";
            ctx.fillText("z: deleteLast", -800,-430);
            ctx.strokeStyle = "#333";
            ctx.moveTo(-800,0);
            ctx.lineTo(800,0);
            ctx.moveTo(-400,-400);
            ctx.lineTo(-400,400);
            ctx.moveTo(0,-400);
            ctx.lineTo(0,400);
            ctx.moveTo(400,-400);
            ctx.lineTo(400,400);
            ctx.stroke();
            ctx.strokeStyle = "#999";
            ctx.strokeRect(-850,-450,1700,900);

            let colorCount = 0;
            ctx.beginPath();
            blocks.forEach((block) => {
                ctx.rect(...block);
            })
            ctx.lineWidth = 5;
            ctx.fillStyle = "#ffffff44";
            ctx.fill();
            ctx.strokeStyle = "#666";
            ctx.stroke();
            
            ctx.lineWidth = 3;

            if (mouse.startPoint) {
                ctx.beginPath();
                ctx.rect(...mouse.startPoint, mouse.gridx-mouse.startPoint[0], mouse.gridy-mouse.startPoint[1]);
                ctx.strokeStyle = "#ccc";
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(mouse.x+5,mouse.y+5);
            ctx.lineTo(mouse.x+30,mouse.y+20);
            ctx.lineTo(mouse.x+20,mouse.y+30);
            ctx.closePath();
            ctx.rect(mouse.gridx, mouse.gridy-2.5, 5, 5);
            ctx.fillStyle = "#ccc";
            ctx.fill();
        }

        function input(input) {
            path = JSON.parse(input);
        }

        setInterval( tickloop, 1000/60 );
    </script>
</body>