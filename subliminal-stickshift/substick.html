<html lang="en">
<head>
    <title>SubLiminal StickShift</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jura:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <style>
        body {
            background-color: #222;
            margin: auto;
            height: 100%;
            overflow: hidden;
            cursor: none;
        }
        .jura {
            font-family: "Jura", sans-serif;
            font-optical-sizing: auto;
            font-weight: 700;
            font-style: normal;
        }
    </style>
    <canvas onmousemove="xy(event)" id="gameScreen" width="1800" height="1000"></canvas>
    <p id="fps">60</p>
    <script>
        // initialize the timer variables and start the animation

        function startAnimating(fps) {
            fpsInterval = 1000 / fps;
            then = Date.now();
            startTime = then;
            animate();
        }

        // the animation loop calculates time elapsed since the last loop
        // and only draws if your specified fps interval is achieved

        function animate() {

            // request another frame

            requestAnimationFrame(animate);

            // calc elapsed time since last loop

            now = Date.now();
            elapsed = now - then;

            // if enough time has elapsed, draw the next frame

            if (elapsed > fpsInterval) {

                // Get ready for next frame by setting then=now, but also adjust for your
                // specified fpsInterval not being a multiple of RAF's interval (16.7ms)
                then = now - (elapsed % fpsInterval);

                // Put your drawing code here
                tickloop();
            }
        }
        //canvas or gamescreen
        var canvas = document.getElementById("gameScreen");
        //context, for drawing
        var ctx = canvas.getContext("2d");
        //settings canvas size and scale
        var screenScale = window.innerWidth/1800;
        if (window.innerHeight/1000 < screenScale) screenScale = window.innerHeight/1000;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.translate(window.innerWidth/2, window.innerHeight/2);

        ctx.scale(screenScale, screenScale);

        //resizing
        window.addEventListener("resize", (  ) => {
            ctx.resetTransform();

            //settings canvas size and scale
            screenScale = window.innerWidth/1800;
            if (window.innerHeight/1000 < screenScale) screenScale = window.innerHeight/1000;

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            ctx.translate(window.innerWidth/2, window.innerHeight/2);

            ctx.scale(screenScale, screenScale);

            ctx.lineWidth = 10;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.lineJoin = "round";
            ctx.lineCap = "round";

            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.fillRect(-1000,-1000,1800+1000,1000+1000);

            ctx.font = "100px serif";
        });

        const mouse = {
            x: 0,
            y: 0,
            down: false
        };

        const keys = [];

        //detect keypresses
        window.addEventListener('keydown', function (e) { if (!e.repeat) {
            const key = e.key.toLowerCase();
            if (!keys.includes(key) && !game.menu) keys.push(key);

            if (key == "-") stats.hueShift = !stats.hueShift;
        }}, false);
        window.addEventListener('keyup', function (e) {
            const key = e.key.toLowerCase();
            while (keys.includes(key)) {
                keys.splice(keys.indexOf(key), 1);
            }
        }, false);
        window.addEventListener('mousedown', function (e) {
            mouse.down = true;

            mouse.selected = mouse.hover;
            if (mouse.selected == "wheel") {
                const wheelAngle = -car.wheel*Math.PI*5/2+Math.PI/2;
                const mouseWheelAngle = Math.atan( (mouse.y-250) / (mouse.x+200) ) + Math.PI*(mouse.x > -200);

                //difference
                mouse.wheelOffset = mouseWheelAngle-wheelAngle;

                while (Math.abs(mouse.wheelOffset-Math.PI*2) < Math.abs(mouse.wheelOffset)) mouse.wheelOffset -= Math.PI*2;
                while (Math.abs(mouse.wheelOffset+Math.PI*2) < Math.abs(mouse.wheelOffset)) mouse.wheelOffset += Math.PI*2;
            }

            if (mouse.selected == "ignition") {
                car.running = !car.running;
                game.timerCounting = true;
            }

            if (game.status == "choosing") chooseChoice();
        }, false);
        window.addEventListener('mouseup', function (e) {
            mouse.down = false;

            mouse.selected = false;
        }, false);
        window.oncontextmenu = () => {
            return false;
        }
        function xy(e) {
            mouse.x = e.x/screenScale - (window.innerWidth)/2/screenScale;
            mouse.y = e.y/screenScale - (window.innerHeight)/2/screenScale;

            if (game.status == "driving") checkHover();
        }

        // initialize the timer variables and start the animation

        function startAnimating(fps) {
            fpsInterval = 1000 / fps;
            then = Date.now();
            startTime = then;
            animate();
        }

        var filterStrength = 10; //used  to be 20
        var frameTime = 0, lastLoop = new Date, thisLoop;
        var fpsOut = document.getElementById('fps');

        // Report the fps only every second, to only lightly affect measurements
        setInterval(function(){
            fpsOut.innerHTML = (1000/frameTime).toFixed(1);
            game.fps = Math.max(30, Number(fpsOut.innerHTML));
        },1000);

        ctx.lineWidth = 10;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
    </script>
    <script>
        //drawFunction 300 width centered
        const stackablePerks = [
            {
                name: "Wider Road",
                desc: "Increased road width",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.moveTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-67.5,90);
                    ctx.lineTo(-52.5, 70);
                    ctx.moveTo(-37.5,50);
                    ctx.lineTo(-22.5, 30);
                    ctx.moveTo(-7.5, 10);
                    ctx.lineTo(7.5, -10);
                    ctx.moveTo(22.5,-30);
                    ctx.lineTo(37.5, -50);
                    ctx.moveTo(52.5,-70);
                    ctx.lineTo(67.5, -90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-30,-20);
                    ctx.lineTo(-60,20);
                    ctx.lineTo(-110,20);
                    ctx.lineTo(-125,40);
                    ctx.lineTo(-150,0);
                    ctx.lineTo(-65,-40);
                    ctx.lineTo(-80,-20);
                    ctx.closePath();
                    ctx.moveTo(30,20);
                    ctx.lineTo(60,-20);
                    ctx.lineTo(110,-20);
                    ctx.lineTo(125,-40);
                    ctx.lineTo(150,0);
                    ctx.lineTo(65,40);
                    ctx.lineTo(80,20);
                    ctx.closePath();
                    ctx.fillStyle = "#ffffff33";
                    ctx.fill();
                    ctx.strokeStyle = "#999";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Wider",0,-150);
                        ctx.fillText("Wider",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.roadSize *= 1.1;
                }
            },
            {
                name: "Straighter Roads",
                desc: "Decrease the curvature of roads",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(-50,50);
                    ctx.lineTo(25,0);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(-150,-100);
                    ctx.lineTo(-100,-100);
                    ctx.lineTo(75,-50);
                    ctx.lineTo(125,0);
                    ctx.lineTo(100,50);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-75,100);
                    ctx.lineTo(-25,75);
                    ctx.moveTo(25,50);
                    ctx.lineTo(50,25);
                    ctx.moveTo(75,0);
                    ctx.lineTo(50,-25);
                    ctx.moveTo(25,-50);
                    ctx.lineTo(-30,-70);
                    ctx.moveTo(-125,-100);
                    ctx.lineTo(-87.5,-90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(-50,50);
                    ctx.lineTo(25,0);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(-150,-100);
                    ctx.moveTo(-100,-100);
                    ctx.lineTo(75,-50);
                    ctx.lineTo(125,0);
                    ctx.lineTo(100,50);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-70,50);
                    ctx.lineTo(-10,50);
                    ctx.lineTo(50,-30);
                    ctx.lineTo(80,-30);
                    ctx.lineTo(50,-70);
                    ctx.lineTo(-40,-30);
                    ctx.lineTo(-10,-30);
                    ctx.closePath();
                    ctx.fillStyle = "#ffffff33";
                    ctx.fill();
                    ctx.strokeStyle = "#999";
                    ctx.stroke();
                

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Straighter",0,-150);
                        ctx.fillText("Straighter",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.roadAngle *= 0.8;
                }
            },
            {
                name: "Longer Timer",
                desc: "Increased time allotted for levels",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(90,-80);
                    ctx.lineTo(80,-90);
                    ctx.lineTo(0,0);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#666";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(95,-75);
                    ctx.lineTo(75,-95);
                    ctx.lineTo(85,-105);
                    ctx.lineTo(105,-85);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#ccc";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    ctx.fillStyle = "#ffc";
                    ctx.fill();
                    ctx.strokeStyle = "#990";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-30,-80);
                    ctx.lineTo(0,0);
                    ctx.lineTo(50,-40);
                    ctx.strokeStyle = "#900";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, -80);
                    ctx.lineTo(70, -10);
                    ctx.lineTo(30, -10);
                    ctx.lineTo(30, 70);
                    ctx.lineTo(-30, 70);
                    ctx.lineTo(-30, -10);
                    ctx.lineTo(-70, -10);
                    ctx.closePath();
                    ctx.fillStyle = "#ffffff99";
                    ctx.fill();
                    ctx.strokeStyle = "#33993399";
                    ctx.stroke();


                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Longer",0,-150);
                        ctx.fillText("Longer",0,-150);
                        ctx.strokeText("Timer",0,150);
                        ctx.fillText("Timer",0,150);
                    }
                },
                chooseFunction() {
                    stats.timerMax *= 1.15;
                }
            },
            {
                name: "Offroad Tires",
                desc: "Reduces the deceleration speed off-road",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(0,0,50,0,Math.PI*2, true);
                    let num = 0;
                    for(var i = 0; i <= Math.PI*2; i += Math.PI/18) {
                        num++;
                        ctx.lineTo((100-20*(num == 3))*Math.cos(i),(100-20*(num == 3))*Math.sin(i));
                        if (num == 3) num = 0;
                    }
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Offroad",0,-150);
                        ctx.fillText("Offroad",0,-150);
                        ctx.strokeText("Tires",0,150);
                        ctx.fillText("Tires",0,150);
                    }
                },
                chooseFunction() {
                    stats.offroadSpeedLoss *= 0.35;
                }
            },
            {
                name: "Grippy Tires",
                desc: "Increased Drifting friction",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(0,0,80,0,Math.PI*2);
                    let num = 0;
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();
                    ctx.beginPath();
                    for(var i = 0; i <= Math.PI*2; i += Math.PI/10) {
                        ctx.moveTo(100*Math.cos(i),100*Math.sin(i));
                        ctx.lineTo(110*Math.cos(i),110*Math.sin(i));
                    }
                    ctx.strokeStyle = "#ffff0099";
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(0,0,55,0,Math.PI*2);
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Grippy",0,-150);
                        ctx.fillText("Grippy",0,-150);
                        ctx.strokeText("Tires",0,150);
                        ctx.fillText("Tires",0,150);
                    }
                },
                chooseFunction() {
                    stats.driftGrip *= 1.3;
                    stats.requiredDriftAngle *= 1.2;
                }
            },
        ]

        const unStackablePerks = [
            {
                name: "Metal Pedal",
                desc: "Lot more acceleration, little more top speed",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(60,-140,200,Math.PI*9/10,Math.PI*2/3, true);
                    ctx.arc(60,-140,160,Math.PI*2/3,Math.PI*9/10);
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-60,-40);
                    ctx.lineTo(20,-60);
                    ctx.lineTo(60,80);
                    ctx.lineTo(-20,100);
                    ctx.closePath();
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-30,-20);
                    ctx.lineTo(-5,70);
                    ctx.moveTo(0,-30);
                    ctx.lineTo(25,60);
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Metal",0,-150);
                        ctx.fillText("Metal",0,-150);
                        ctx.strokeText("Pedal",0,150);
                        ctx.fillText("Pedal",0,150);
                    }
                },
                chooseFunction() {
                    stats.acceleration *= 3;
                    stats.topSpeed *= 1.1;
                }
            },
            {
                name: "Spedometer",
                desc: "Higher Top Speed but lower acceleration",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(0,-0,100,Math.PI-Math.PI/5,Math.PI/5);
                    ctx.lineTo(50,50);
                    ctx.lineTo(-50,50);
                    ctx.closePath();
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();

                    ctx.beginPath();
                    for(var i = Math.PI/8; i >= -Math.PI-Math.PI/8; i -= Math.PI/4) {
                        ctx.moveTo(85*Math.cos(i),85*Math.sin(i));
                        ctx.lineTo(95*Math.cos(i),95*Math.sin(i));
                    }
                    ctx.strokeStyle = "#999";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0,0)
                    ctx.lineTo(10,-90);
                    ctx.strokeStyle = "#c00";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#c00";
                        ctx.strokeText("Speedometer",0,150);
                        ctx.fillText("Speedometer",0,150);
                    }
                },
                chooseFunction() {
                    stats.topSpeed *= 1.65;
                    stats.acceleration *= 0.8;
                }
            },
            {
                name: "Buggy Build",
                desc: "Increases Off-Road capabilties",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-120,-50);
                    ctx.lineTo(120,-50);
                    ctx.moveTo(-120,50);
                    ctx.lineTo(120,50);
                    ctx.moveTo(-10,-50);
                    ctx.lineTo(-10,50);
                    ctx.moveTo(10,-50);
                    ctx.lineTo(10,50);
                    ctx.moveTo(-100,50);
                    ctx.lineTo(-100,30);
                    ctx.lineTo(-80,30);
                    ctx.lineTo(-80,10);
                    ctx.lineTo(-60,10);
                    ctx.lineTo(-60,-10);
                    ctx.lineTo(-40,-10);
                    ctx.lineTo(-40,-30);
                    ctx.lineTo(-20,-30);
                    ctx.lineTo(-20,-50);
                    ctx.moveTo(100,50);
                    ctx.lineTo(100,30);
                    ctx.lineTo(80,30);
                    ctx.lineTo(80,10);
                    ctx.lineTo(60,10);
                    ctx.lineTo(60,-10);
                    ctx.lineTo(40,-10);
                    ctx.lineTo(40,-30);
                    ctx.lineTo(20,-30);
                    ctx.lineTo(20,-50);
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.strokeStyle = "#666";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.rect(-140, -70, 40, 140);
                    ctx.rect(100, -70, 40, 140);
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Buggy",0,-150);
                        ctx.fillText("Buggy",0,-150);
                        ctx.strokeText("Build",0,150);
                        ctx.fillText("Build",0,150);
                    }
                },
                chooseFunction() {
                    stats.offroadSpeedLoss *= 0.25;
                    stats.offroadMaxSpeed *= 2.3;
                }
            },
            {
                name: "EZ Drive",
                desc: "Wider, straighter, and Shorter roads",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.moveTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-67.5,90);
                    ctx.lineTo(-52.5, 70);
                    ctx.moveTo(-37.5,50);
                    ctx.lineTo(-22.5, 30);
                    ctx.moveTo(-7.5, 10);
                    ctx.lineTo(7.5, -10);
                    ctx.moveTo(22.5,-30);
                    ctx.lineTo(37.5, -50);
                    ctx.moveTo(52.5,-70);
                    ctx.lineTo(67.5, -90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.save();

                    ctx.rotate(Math.PI/10);
                    
                    ctx.fillStyle = "#0f0";
                    ctx.strokeStyle = "#0f0";
                    ctx.font = "100px Jura";
                    ctx.fillText("EZ",0,0);
                    ctx.beginPath();
                    ctx.rect(-100,-62.5,200,125)
                    ctx.stroke();

                    ctx.restore();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("E Z",0,-150);
                        ctx.fillText("E Z",0,-150);
                        ctx.strokeText("Drive",0,150);
                        ctx.fillText("Drive",0,150);
                    }
                },
                chooseFunction() {
                    stats.roadAngle *= 0.80;
                    stats.roadSize *= 1.2;
                    stats.roadLength *= 0.85;
                }
            },
            {
                name: "Look Ma', No hands",
                desc: "Increased speed while not holding the the wheel",
                drawFunction(timer) {

                    //wheel
                    ctx.save();
                    ctx.rotate(Math.PI/5);
                    
                    ctx.strokeStyle = "#333";
                    ctx.fillStyle = "#ad7d53";
                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    ctx.moveTo(-80,0);
                    ctx.arc(0,0,80,0,Math.PI*2, true);
                    ctx.rect(-90,-10,180,20);
                    ctx.rect(-10,0,20,90);
                    ctx.stroke();
                    ctx.fill();

                    ctx.restore();

                    ctx.beginPath();
                    for(var i = 0; i <= Math.PI*2; i += Math.PI/10) {
                        ctx.moveTo(110*Math.cos(i),110*Math.sin(i));
                        ctx.lineTo(120*Math.cos(i),120*Math.sin(i));
                    }
                    ctx.strokeStyle = "#ffff0099";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Look Ma'",0,-150);
                        ctx.fillText("Look Ma'",0,-150);
                        ctx.strokeText("No hands",0,150);
                        ctx.fillText("No hands",0,150);
                    }
                },
                chooseFunction() {
                    stats.noHands = true;
                }
            },
            {
                name: "Offroad Cruisin'",
                desc: "No speed penalty on offroad if the engine is off",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(-30,0,50,0,Math.PI*2, true);
                    let num = 0;
                    for(var i = 0; i <= Math.PI*2; i += Math.PI/18) {
                        num++;
                        ctx.lineTo(-30+(100-20*(num == 3))*Math.cos(i),(100-20*(num == 3))*Math.sin(i));
                        if (num == 3) num = 0;
                    }
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(90,0);
                    ctx.lineTo(150,0);
                    ctx.moveTo(80,-40);
                    ctx.lineTo(140,-40);
                    ctx.moveTo(80,40);
                    ctx.lineTo(140,40);
                    ctx.moveTo(50,-80);
                    ctx.lineTo(110,-80);
                    ctx.moveTo(50,80);
                    ctx.lineTo(110,80);
                    ctx.strokeStyle = "#999";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(-30,0,25,0,Math.PI*2);
                    
                    ctx.fillStyle = "#922";
                    ctx.fill();
                    ctx.strokeStyle = "#222";
                    ctx.stroke();

                    ctx.beginPath();

                    ctx.moveTo(-30-10*(1-2*car.running),-10);
                    ctx.lineTo(-30+10*(1-2*car.running),10);

                    ctx.strokeStyle = "#666";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Offroad",0,-150);
                        ctx.fillText("Offroad",0,-150);
                        ctx.strokeText("Cruisin'",0,150);
                        ctx.fillText("Cruisin'",0,150);
                    }
                },
                chooseFunction() {
                    stats.offroadCruise = true;
                }
            },
            {
                name: "Anti-Lock Brakes",
                desc: "Much harder to drift and slide out",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    ctx.moveTo(90,-90);
                    ctx.arc(0,0,125,-Math.PI/4,Math.PI/4);
                    ctx.lineTo(90,90);
                    ctx.moveTo(-90,90);
                    ctx.arc(0,0,125,Math.PI-Math.PI/4,Math.PI*5/4);
                    ctx.lineTo(-90,-90);
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.strokeStyle = "#950";
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.strokeStyle = "#fc3";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.font = "75px Jura";
                    ctx.strokeStyle = "#950";
                    ctx.fillStyle = "#fc3";
                    ctx.strokeText("ABS",0,0);
                    ctx.fillText("ABS",0,0);

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#950";
                        ctx.fillStyle = "#fc3";
                        ctx.strokeText("Anti-Lock",0,-150);
                        ctx.fillText("Anti-Lock",0,-150);
                        ctx.strokeText("Brakes",0,150);
                        ctx.fillText("Brakes",0,150);
                    }
                },
                chooseFunction() {
                    stats.requiredDriftAngle *= 3.5;
                }
            },
            {
                name: "No-Drift Wipers",
                desc: "Impossible to slip out on side of your windshield wipers",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(-50,25,80,0,Math.PI*2);
                    let num = 0;
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(-50,25,55,0,Math.PI*2);
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();

                    ctx.moveTo(-50,25);
                    ctx.arc(-50,25,75,-Math.PI/6, -Math.PI/4, true);
                    ctx.moveTo(-50,25);
                    ctx.arc(-50,25,100,-Math.PI/6, -Math.PI/3, true);
                    ctx.moveTo(-50,25);
                    ctx.arc(-50,25,125,-Math.PI/6, -Math.PI/2, true);
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.strokeStyle = "#666";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("No-Drift",0,-150);
                        ctx.fillText("No-Drift",0,-150);
                        ctx.strokeText("Wipers",0,150);
                        ctx.fillText("Wipers",0,150);
                    }
                },
                chooseFunction() {
                    stats.driftWiper = true;
                }
            },
            {
                name: "Boosters",
                desc: "Boosters spawn on the road",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,0);
                    ctx.lineTo(150,100);
                    ctx.moveTo(-125,50);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(125,50);
                    ctx.moveTo(-100,0);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(100,0);
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.strokeStyle = "#950";
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.strokeStyle = "#fc3";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#950";
                        ctx.fillStyle = "#fc3";
                        ctx.strokeText("Boosters",0,150);
                        ctx.fillText("Boosters",0,150);
                    }
                },
                chooseFunction() {
                    stats.booster = true;
                }
            },
        ]

        const stackablePunishments = [
            {
                name: "Thin Road",
                desc: "Roads are thinner",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.moveTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-67.5,90);
                    ctx.lineTo(-52.5, 70);
                    ctx.moveTo(-37.5,50);
                    ctx.lineTo(-22.5, 30);
                    ctx.moveTo(-7.5, 10);
                    ctx.lineTo(7.5, -10);
                    ctx.moveTo(22.5,-30);
                    ctx.lineTo(37.5, -50);
                    ctx.moveTo(52.5,-70);
                    ctx.lineTo(67.5, -90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(150,-20);
                    ctx.lineTo(120,20);
                    ctx.lineTo(70,20);
                    ctx.lineTo(45,40);
                    ctx.lineTo(30,0);
                    ctx.lineTo(115,-40);
                    ctx.lineTo(100,-20);
                    ctx.closePath();
                    ctx.moveTo(-150,20);
                    ctx.lineTo(-120,-20);
                    ctx.lineTo(-70,-20);
                    ctx.lineTo(-55,-40);
                    ctx.lineTo(-30,0);
                    ctx.lineTo(-115,40);
                    ctx.lineTo(-100,20);
                    ctx.closePath();
                    ctx.fillStyle = "#ffffff33";
                    ctx.fill();
                    ctx.strokeStyle = "#999";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Thinner",0,-150);
                        ctx.fillText("Thinner",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.roadSize *= 0.7;
                }
            },
            {
                name: "Curvy Roads",
                desc: "Increase the curvature of roads",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(-50,50);
                    ctx.lineTo(25,0);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(-150,-100);
                    ctx.lineTo(-100,-100);
                    ctx.lineTo(75,-50);
                    ctx.lineTo(125,0);
                    ctx.lineTo(100,50);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-75,100);
                    ctx.lineTo(-25,75);
                    ctx.moveTo(25,50);
                    ctx.lineTo(50,25);
                    ctx.moveTo(75,0);
                    ctx.lineTo(50,-25);
                    ctx.moveTo(25,-50);
                    ctx.lineTo(-30,-70);
                    ctx.moveTo(-125,-100);
                    ctx.lineTo(-87.5,-90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(-50,50);
                    ctx.lineTo(25,0);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(-150,-100);
                    ctx.moveTo(-100,-100);
                    ctx.lineTo(75,-50);
                    ctx.lineTo(125,0);
                    ctx.lineTo(100,50);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Curvy",0,-150);
                        ctx.fillText("Curvy",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.roadAngle *= 1.45;
                }
            },
            {
                name: "Longer Road",
                desc: "Longer road, more time allotted",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.moveTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-67.5,90);
                    ctx.lineTo(-52.5, 70);
                    ctx.moveTo(-37.5,50);
                    ctx.lineTo(-22.5, 30);
                    ctx.moveTo(-7.5, 10);
                    ctx.lineTo(7.5, -10);
                    ctx.moveTo(22.5,-30);
                    ctx.lineTo(37.5, -50);
                    ctx.moveTo(52.5,-70);
                    ctx.lineTo(67.5, -90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-140,50);
                    ctx.lineTo(-80,50);
                    ctx.lineTo(-20,-30);
                    ctx.lineTo(10,-30);
                    ctx.lineTo(-20,-70);
                    ctx.lineTo(-110,-30);
                    ctx.lineTo(-80,-30);
                    ctx.closePath();

                    ctx.moveTo(10,50);
                    ctx.lineTo(70,50);
                    ctx.lineTo(130,-30);
                    ctx.lineTo(160,-30);
                    ctx.lineTo(130,-70);
                    ctx.lineTo(40,-30);
                    ctx.lineTo(70,-30);
                    ctx.closePath();
                    ctx.fillStyle = "#ffffff33";
                    ctx.fill();
                    ctx.strokeStyle = "#999";
                    ctx.stroke();
                

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Longer",0,-150);
                        ctx.fillText("Longer",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.roadLength *= 1.2;
                    stats.timerMax *= 1.15;
                }
            },
            {
                name: "Shorter Timer",
                desc: "Reduced time allotted for levels",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(90,-80);
                    ctx.lineTo(80,-90);
                    ctx.lineTo(0,0);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#666";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(95,-75);
                    ctx.lineTo(75,-95);
                    ctx.lineTo(85,-105);
                    ctx.lineTo(105,-85);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#ccc";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    ctx.fillStyle = "#ffc";
                    ctx.fill();
                    ctx.strokeStyle = "#990";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-30,-80);
                    ctx.lineTo(0,0);
                    ctx.lineTo(50,-40);
                    ctx.strokeStyle = "#900";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, 80);
                    ctx.lineTo(70, 10);
                    ctx.lineTo(30, 10);
                    ctx.lineTo(30, -70);
                    ctx.lineTo(-30, -70);
                    ctx.lineTo(-30, 10);
                    ctx.lineTo(-70, 10);
                    ctx.closePath();
                    ctx.fillStyle = "#ffffff99";
                    ctx.fill();
                    ctx.strokeStyle = "#99333399";
                    ctx.stroke();


                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Shorter",0,-150);
                        ctx.fillText("Shorter",0,-150);
                        ctx.strokeText("Timer",0,150);
                        ctx.fillText("Timer",0,150);
                    }
                },
                chooseFunction() {
                    stats.timerMax *= 0.92;
                }
            },
            {
                name: "Light Breeze",
                desc: "Winds can nudge you around",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.save();
                    ctx.translate(-50,0);
                    for (var i = 0; i < 4; i++) {
                        ctx.moveTo(-100,0);
                        ctx.arc(0,-50,50,Math.PI/2, -Math.PI/3, true);

                        ctx.translate(50,25);
                    }

                    ctx.strokeStyle = "#999";
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.stroke();
                    ctx.strokeStyle = "#ccc";
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.stroke();

                    ctx.restore();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#999";
                        ctx.fillStyle = "#ccc";
                        ctx.strokeText("Light",0,-150);
                        ctx.fillText("Light",0,-150);
                        ctx.strokeText("Breeze",0,150);
                        ctx.fillText("Breeze",0,150);
                    }
                },
                chooseFunction() {
                    if (!stats.wind) {
                        stats.wind = true;
                        stats.windForce = 0;
                    }
                    stats.windForce += 0.15;
                }
            },
            {
                name: "Slick Tires",
                desc: "Reduced Drifting friction",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(0,0,80,0,Math.PI*2);
                    let num = 0;
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#333";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    for(var i = 0; i <= Math.PI*2; i += Math.PI/10) {
                        ctx.moveTo(100*Math.cos(i),100*Math.sin(i));
                        ctx.lineTo(110*Math.cos(i),110*Math.sin(i));
                    }
                    ctx.strokeStyle = "#00ffff99";
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(0,0,55,0,Math.PI*2);
                    ctx.strokeStyle = "#666";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Slick",0,-150);
                        ctx.fillText("Slick",0,-150);
                        ctx.strokeText("Tires",0,150);
                        ctx.fillText("Tires",0,150);
                    }
                },
                chooseFunction() {
                    stats.driftGrip *= 0.6;
                    stats.requiredDriftAngle *= 0.75;
                }
            },
            {
                name: "Road Hazards",
                desc: "Increased road hazard chances, reduced off-road speed",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-125,100)
                    ctx.lineTo(125,100);
                    ctx.lineTo(0,-100);
                    ctx.closePath();
                    ctx.strokeStyle = "#640";
                    ctx.fillStyle = "#a93";
                    ctx.stroke();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(0,-75)
                    ctx.lineTo(0,50);
                    ctx.moveTo(0,75)
                    ctx.lineTo(0,80);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.stroke();
                    ctx.strokeStyle = "#111";
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#640";
                        ctx.fillStyle = "#a93";
                        ctx.strokeText("Road",0,-150);
                        ctx.fillText("Road",0,-150);
                        ctx.strokeText("Hazards",0,150);
                        ctx.fillText("Hazards",0,150);
                    }
                },
                chooseFunction() {
                    stats.roadHazardChance *= 1.7;
                    stats.offroadSpeedLoss *= 1.4;
                }
            },
        ]

        const unStackablePunishments = [
            {
                name: "F O G",
                desc: "The  F O G  is here: Heavily obscures vision",
                drawFunction(timer) {
                    ctx.beginPath();
                    linearGradient = ctx.createLinearGradient(0, -200, 0, 200);

                    linearGradient.addColorStop(0, "#cccccc99");
                    linearGradient.addColorStop(0.1, "#cccccc");
                    linearGradient.addColorStop(1, "#cccccc00");

                    ctx.fillStyle = linearGradient;
                    ctx.moveTo(-100,0);
                    ctx.lineTo(-70,70);
                    ctx.lineTo(0,100);
                    ctx.lineTo(70,70);
                    ctx.lineTo(100,0);
                    ctx.lineTo(70,-70);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(-70,-70);
                    ctx.closePath();
                    ctx.strokeStyle = "#ccc";
                    ctx.fill();
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#999";
                        ctx.fillStyle = "#ccc";
                        ctx.strokeText("F O G",0,150);
                        ctx.fillText("F O G",0,150);
                    }
                },
                chooseFunction() {
                    stats.fog = true;
                },
            },
            {
                name: "Unpowered Steering",
                desc: "Heavily reduces turning speed",
                drawFunction(timer) {
                    ctx.save();
                    ctx.rotate(-Math.PI/6);

                    ctx.beginPath();
                    ctx.rect(50,-15,80,30);
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.rect(-120,-30,170,60);
                    ctx.rect(120,-20,20,40);
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#69c";
                    ctx.fill();

                    ctx.restore();

                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    ctx.moveTo(-65, -65);
                    ctx.lineTo(65, 65);
                    
                    ctx.strokeStyle = "#900";
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.stroke();
                    ctx.strokeStyle = "#c00";
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#69c";
                        ctx.strokeText("Unpowered",0,-150);
                        ctx.fillText("Unpowered",0,-150);
                        ctx.strokeText("Steering",0,150);
                        ctx.fillText("Steering",0,150);
                    }
                },
                chooseFunction() {
                    stats.turnSpeed *= 0.3;
                }
            },
            {
                name: "Pot Holes",
                desc: "Pot holes can spawn on the road",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.moveTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-67.5,90);
                    ctx.lineTo(-52.5, 70);
                    ctx.moveTo(-37.5,50);
                    ctx.lineTo(-22.5, 30);
                    ctx.moveTo(-7.5, 10);
                    ctx.lineTo(7.5, -10);
                    ctx.moveTo(22.5,-30);
                    ctx.lineTo(37.5, -50);
                    ctx.moveTo(52.5,-70);
                    ctx.lineTo(67.5, -90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(-10,-40,15,0,Math.PI*2);
                    ctx.moveTo(30,30);
                    ctx.arc(15,30,15,0,Math.PI*2);
                    ctx.moveTo(-45,40);
                    ctx.arc(-60,40,15,0,Math.PI*2);
                    ctx.strokeStyle = "#999";
                    ctx.stroke();
                    ctx.fillStyle = "#222";
                    ctx.fill();
                

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#990";
                        ctx.strokeText("Pot",0,-150);
                        ctx.fillText("Pot",0,-150);
                        ctx.strokeText("Holes",0,150);
                        ctx.fillText("Holes",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.potholes = true;
                }
            },
            {
                name: "Strong Winds",
                desc: "Winds can push you around",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.save();
                    ctx.translate(-100,30);
                    for (var i = 0; i < 4; i++) {
                        ctx.moveTo(-50,0);
                        ctx.arc(0,-25,25,Math.PI/2, -Math.PI/3, true);

                        ctx.translate(50,25);
                    }
                    ctx.translate(-100,-150);
                    for (var i = 0; i < 4; i++) {
                        ctx.moveTo(-50,0);
                        ctx.arc(0,-25,25,Math.PI/2, -Math.PI/3, true);

                        ctx.translate(50,25);
                    }

                    ctx.strokeStyle = "#999";
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.stroke();
                    ctx.strokeStyle = "#ccc";
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.stroke();

                    ctx.restore();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#999";
                        ctx.fillStyle = "#ccc";
                        ctx.strokeText("Strong",0,-150);
                        ctx.fillText("Strong",0,-150);
                        ctx.strokeText("Winds",0,150);
                        ctx.fillText("Winds",0,150);
                    }
                },
                chooseFunction() {
                    if (!stats.wind) {
                        stats.wind = true;
                        stats.windForce = 0;
                    }
                    stats.windForce += 0.4;
                }
            },
            {
                name: "Slippery Road",
                desc: "Drifts are harder to control",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(-50,50);
                    ctx.lineTo(25,0);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(-150,-100);
                    ctx.lineTo(-100,-100);
                    ctx.lineTo(75,-50);
                    ctx.lineTo(125,0);
                    ctx.lineTo(100,50);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#356"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-75,100);
                    ctx.lineTo(-25,75);
                    ctx.moveTo(25,50);
                    ctx.lineTo(50,25);
                    ctx.moveTo(75,0);
                    ctx.lineTo(50,-25);
                    ctx.moveTo(25,-50);
                    ctx.lineTo(-30,-70);
                    ctx.moveTo(-125,-100);
                    ctx.lineTo(-87.5,-90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(-50,50);
                    ctx.lineTo(25,0);
                    ctx.lineTo(0,-50);
                    ctx.lineTo(-150,-100);
                    ctx.moveTo(-100,-100);
                    ctx.lineTo(75,-50);
                    ctx.lineTo(125,0);
                    ctx.lineTo(100,50);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#356";
                        ctx.strokeText("Slippery",0,-150);
                        ctx.fillText("Slippery",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.driftGrip *= 0.4;
                    stats.requiredDriftAngle *= 0.2;
                    stats.slipRoad = true;
                }
            },
            {
                name: "Sweaty Palms",
                desc: "Every once and a while, you lose grip",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-60,100);
                    ctx.lineTo(-75,0);
                    ctx.lineTo(-70,-75);
                    ctx.lineTo(-60,-75);
                    ctx.lineTo(-55,-0);
                    ctx.lineTo(-50,-90);
                    ctx.lineTo(-40,-90);
                    ctx.lineTo(-35,-0);
                    ctx.lineTo(-30,-100);
                    ctx.lineTo(-20,-100);
                    ctx.lineTo(-15,-0);
                    ctx.lineTo(-10,-90);
                    ctx.lineTo(0,-90);
                    ctx.lineTo(5,0);
                    ctx.lineTo(15,30);
                    ctx.lineTo(40,-30);
                    ctx.lineTo(47,-27);
                    ctx.lineTo(30,40);
                    ctx.lineTo(10,90);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#c96";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#c96";
                        ctx.strokeText("Sweaty",0,-150);
                        ctx.fillText("Sweaty",0,-150);
                        ctx.strokeText("Palms",0,150);
                        ctx.fillText("Palms",0,150);
                    }
                },
                chooseFunction() {
                    stats.sweaty = true;
                }
            },
            {
                name: "Old Discs",
                desc: "Braking and reversing compromised, reduced acceleration",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(0,0,80,0,Math.PI*2);
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(0,0,30,0,Math.PI*2);
                    ctx.moveTo(-100,0);
                    ctx.arc(0,0,100,Math.PI,-Math.PI/3);
                    ctx.closePath();
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#222";
                    ctx.fill();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Old",0,-150);
                        ctx.fillText("Old",0,-150);
                        ctx.strokeText("Discs",0,150);
                        ctx.fillText("Discs",0,150);
                    }
                },
                chooseFunction() {
                    stats.noBrake = true;
                    stats.acceleration *= 0.7;
                }
            },
            {
                name: "Failing Engine",
                desc: "The engine turns off every once and a while, reduced top speed",
                drawFunction(timer) {
                    ctx.save();
                    ctx.rotate(-Math.PI/12);

                    ctx.beginPath();
                    ctx.rect(-120,-80,240,160);
                    ctx.strokeStyle = "#333";
                    ctx.stroke();
                    ctx.fillStyle = "#999";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.rect(-115,-15,230,30);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();
                    ctx.fillStyle = "#444";
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(-75,-50,20,0,Math.PI*2);
                    ctx.moveTo(20,-50);
                    ctx.arc(0,-50,20,0,Math.PI*2);
                    ctx.moveTo(95,-50);
                    ctx.arc(75,-50,20,0,Math.PI*2);
                    ctx.moveTo(-55,50);
                    ctx.arc(-75,50,20,0,Math.PI*2);
                    ctx.moveTo(20,50);
                    ctx.arc(0,50,20,0,Math.PI*2);
                    ctx.moveTo(95,50);
                    ctx.arc(75,50,20,0,Math.PI*2);
                    ctx.strokeStyle = "#333"
                    ctx.stroke();
                    ctx.fillStyle = "#222";
                    ctx.fill();

                    ctx.restore();

                    ctx.beginPath();
                    ctx.arc(0,0,100,0,Math.PI*2);
                    ctx.moveTo(-65, -65);
                    ctx.lineTo(65, 65);
                    
                    ctx.strokeStyle = "#900";
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.stroke();
                    ctx.strokeStyle = "#c00";
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#333";
                        ctx.fillStyle = "#666";
                        ctx.strokeText("Failing",0,-150);
                        ctx.fillText("Failing",0,-150);
                        ctx.strokeText("Engine",0,150);
                        ctx.fillText("Engine",0,150);
                    }
                },
                chooseFunction() {
                    stats.engineFailure = true;
                    stats.topSpeed *= 0.93;
                }
            },
            {
                name: "Oil Spills",
                desc: "Oil spills on the road",
                drawFunction(timer) {
                    ctx.save();
                    ctx.rotate(Math.PI/12);
                    
                    ctx.save();
                    ctx.scale(1,0.5);

                    ctx.beginPath();
                    ctx.arc(0,180,60,0,Math.PI);
                    ctx.rect(-60,-180,120,360);
                    ctx.strokeStyle = "#222";
                    ctx.stroke();
                    ctx.fillStyle = "#444";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0,-180,60,0,Math.PI*2);
                    ctx.strokeStyle = "#222";
                    ctx.stroke();
                    ctx.fillStyle = "#444";
                    ctx.fill();

                    ctx.restore();
                    
                    ctx.beginPath();
                    ctx.beginPath();
                    ctx.arc(80,-50,80,Math.PI,Math.PI*3/4, true);
                    ctx.arc(0,30,40,0,Math.PI);
                    ctx.arc(-80,-50,80,Math.PI/4, 0, true);
                    ctx.strokeStyle = "#222";
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.fill();

                    ctx.restore();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.strokeStyle = "#000";
                        ctx.fillStyle = "#222";
                        ctx.strokeText("Oil",0,-150);
                        ctx.fillText("Oil",0,-150);
                        ctx.strokeText("Spills",0,150);
                        ctx.fillText("Spills",0,150);
                    }
                },
                chooseFunction() {
                    stats.oilslick = true;
                }
            },
            {
                name: "Muddy Road",
                desc: "Wet mud on the road",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.lineTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.fillStyle = "#333"
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-150,100);
                    ctx.lineTo(0,-100);
                    ctx.moveTo(150,-100);
                    ctx.lineTo(0,100);
                    ctx.strokeStyle = "#666"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-67.5,90);
                    ctx.lineTo(-52.5, 70);
                    ctx.moveTo(-37.5,50);
                    ctx.lineTo(-22.5, 30);
                    ctx.moveTo(-7.5, 10);
                    ctx.lineTo(7.5, -10);
                    ctx.moveTo(22.5,-30);
                    ctx.lineTo(37.5, -50);
                    ctx.moveTo(52.5,-70);
                    ctx.lineTo(67.5, -90);
                    ctx.strokeStyle = "#990"
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(15,-10,65,0,Math.PI*2);
                    ctx.strokeStyle = "#321"
                    ctx.stroke();
                    ctx.fillStyle = "#553322cc";
                    ctx.fill();;
                

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.fillStyle = "#532";
                        ctx.strokeStyle = "#321";
                        ctx.strokeText("Muddy",0,-150);
                        ctx.fillText("Muddy",0,-150);
                        ctx.strokeText("Road",0,150);
                        ctx.fillText("Road",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.mud = true;
                }
            },
            {
                name: "Big Bugs",
                desc: "Bugs can splatter on your windsheild",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.arc(-75,-25,65,0,Math.PI*2);
                    ctx.moveTo(140,-25);
                    ctx.arc(75,-25,65,0,Math.PI*2);
                    ctx.fillStyle = "#999";
                    ctx.fill();
                    ctx.strokeStyle = "#ccc";
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0,25,75,0,Math.PI*2);
                    ctx.fillStyle = "#222";
                    ctx.fill();
                    ctx.strokeStyle = "#444";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.fillStyle = "#252";
                        ctx.strokeStyle = "#232";
                        ctx.strokeText("Big",0,-150);
                        ctx.fillText("Big",0,-150);
                        ctx.strokeText("Bugs",0,150);
                        ctx.fillText("Bugs",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.bug = true;
                }
            },
            {
                name: "Sleepy",
                desc: "Every once and a while your eyes close, then re-open",
                drawFunction(timer) {
                    ctx.beginPath();
                    ctx.moveTo(0,-25);
                    ctx.lineTo(100,-25);
                    ctx.lineTo(0,75);
                    ctx.lineTo(100,75);

                    ctx.moveTo(-50,-85);
                    ctx.lineTo(25,-85);
                    ctx.lineTo(-50,-10);
                    ctx.lineTo(25,-10);
                    
                    ctx.moveTo(-90,-115);
                    ctx.lineTo(-40,-115);
                    ctx.lineTo(-90,-65);
                    ctx.lineTo(-40,-65);
                    ctx.lineWidth = game.defaultLineWidth*2;
                    ctx.strokeStyle = "#226";
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.strokeStyle = "#449";
                    ctx.stroke();

                    if (!timer) {
                        ctx.beginPath();
                        ctx.font = "50px Jura";
                        ctx.fillStyle = "#449";
                        ctx.strokeStyle = "#226";
                        ctx.strokeText("Sleepy",0,150);
                        ctx.fillText("Sleepy",0,150);
                    }

                    ctx.lineWidth = game.defaultLineWidth;
                },
                chooseFunction() {
                    stats.sleepy = true;
                    stats.eyePos = 1000;
                    stats.eyeVel = -100;
                }
            },
        ]

        let choices = [];

        let perkChoices = [ "punish", "perk", "unstackPunish", "perk", "punish", "unstackPerk", "punish", "perk", "unstackPunish", "perk", "punish", "unstackPerk", "punish", "perk", "unstackPunish", "final" ];

        let chosenPerkDraw = [];

        const chosenPerk = [];
        const chosenPunish = [];

        let perkChoicePos = 0;

        const regions = [ "abyss", "city", "highway" ];

        regions.sort( () => { if (Math.random() < 0.5) return 1; else return -1; } );

        regions[2] = "red carpet";

        let currentRegion = "rural";

        let stats = {
            roadLength: 80000,
            roadSize: 200,
            roadAngle: Math.PI/20,
            acceleration: 0.05,
            topSpeed: 30,
            turnSpeed: Math.PI/25,
            offroadSpeedLoss: 0.2,
            offroadMaxSpeed: 8,
            requiredDriftAngle: Math.PI/17,
            driftGrip: 0.07,
            inertia: 1,
            roadHazardChance: 1,
            timerMax: 4000,
        }

        const game = { 
            gravity: 0, fps: 60, zoom: 50, xOffset: 0, yOffset: 0, xVOffset: 0, yVOffset: 0,
            renderType: "2d", defaultLineWidth: 10, timer: 0, timerCounting: false, status: "driving",
        };
        generateChoices();

        const car = {
            x: 0,
            y: 0,
            speed: 0,
            speedAngle: Math.PI/2,
            angle: Math.PI/2,
            wheel: 0,
            running: false,
            wiper: 0,
            booster: 0,
        }
        
        let windshield = [];

        let buildings = [];

        let buildingPoints = [];

        let road = [];

        let roadDrawPoints = [];
            
        const horizon = -200;

        const clouds = [];
        for(var i = 0; i < Math.PI*2; i += Math.PI/100*(1+0.5*Math.random())) clouds.push( {angle: i, size: 100+50*Math.random(), y: -400-75*Math.random()} );

        let linearGradient;

        const linearGradientBG = ctx.createLinearGradient(-1800, 0, 1800, 0);

        linearGradientBG.addColorStop(0, "#000000");
        linearGradientBG.addColorStop(0.24, "#000000");
        linearGradientBG.addColorStop(0.25, "#00000000");
        linearGradientBG.addColorStop(0.75, "#00000000");
        linearGradientBG.addColorStop(0.76, "#000000");
        linearGradientBG.addColorStop(1, "#000000");

        const linearGradientBG1 = ctx.createLinearGradient(0, -1000, 0, 1000);

        linearGradientBG1.addColorStop(0, "#000000");
        linearGradientBG1.addColorStop(0.24, "#000000");
        linearGradientBG1.addColorStop(0.25, "#00000000");
        linearGradientBG1.addColorStop(0.75, "#00000000");
        linearGradientBG1.addColorStop(0.76, "#000000");
        linearGradientBG1.addColorStop(1, "#000000");

        const fogGradient = ctx.createLinearGradient(0, -1200, 0, 800);

        fogGradient.addColorStop(0, "#77777750");
        fogGradient.addColorStop(0.5, "#777777ff");
        fogGradient.addColorStop(0.51, "#777777f5");
        fogGradient.addColorStop(0.52, "#777777f0");
        fogGradient.addColorStop(0.55, "#777777c0");
        fogGradient.addColorStop(0.65, "#77777760");
        fogGradient.addColorStop(1, "#77777722");

        function tickloop() {
            //sortBuildings
            if (game.timer%10 == 0) buildingPoints.sort( (a,b) => {
                if (Math.hypot(a[4].x-car.x,a[4].y-car.y) < Math.hypot(b[4].x-car.x,b[4].y-car.y)) return 1; 
                else return -1; 
            } );

            if (Math.random() < 0.003 && stats.sweaty) mouse.selected = false;
            if (Math.random() < 0.002 && stats.engineFailure) car.running = false;
            if (Math.random() < 0.015 && stats.bug && game.timerCounting && game.status == "driving") windshield.push( { type: "bug", x: -600+1200*Math.random(), y: -300+500*Math.random(), durability: 2, maxDurability: 2 } );
            if (Math.random() < 0.15 && stats.sleepy && game.timerCounting && game.status == "driving") stats.eyeVel++;

            ctx.save();

            //check frameRate
            var thisFrameTime = (thisLoop=new Date) - lastLoop;
            frameTime += (thisFrameTime - frameTime) / filterStrength;
            lastLoop = thisLoop;

            ctx.beginPath();
            ctx.fillStyle = "#000000";
            ctx.rect(-1000,-1000,3500,3600);
            ctx.fill();

            drawSkybox();

            drawRoadPerspective();

            drawDash();

            if (perkChoices[perkChoicePos] == "finish" && game.status == "choosing") {
                drawTimer();

                ctx.beginPath();
                ctx.fillStyle = "#ff3";
                ctx.strokeStyle = "#993";
                ctx.font = "200px serif";
                ctx.strokeText("You Win", 0, 0);
                ctx.fillText("You Win", 0, 0);
            } else if (game.timer > stats.timerMax+300) {
                drawTimer();

                ctx.beginPath();
                ctx.fillStyle = "#f33";
                ctx.strokeStyle = "#933";
                ctx.font = "200px serif";
                ctx.strokeText("Game Over", 0, 0);
                ctx.fillText("Game Over", 0, 0);
            } else if (game.status == "choosing") {
                drawTimer();
                drawChoices();
            }
            else {
                drawTimer();

                checkCollision();
                
                drive();

                if (game.timerCounting) game.timer++;
            }

            drawMouse();

            ctx.beginPath();
            ctx.rect(-3600,-3000,6000,6000);

            ctx.fillStyle = linearGradientBG;

            ctx.fill();

            ctx.fillStyle = linearGradientBG1;

            ctx.fill();

            //render the mouse
            if (stats.sleepy && game.status == "driving") {
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(0, -stats.eyePos+2000, 2000, 0, Math.PI*2, true);
                ctx.rect(-1000, -1000, 2000, 2000);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(0, stats.eyePos-2000, 2000, 0, Math.PI*2, true);
                ctx.rect(-1000, -1000, 2000, 2000);
                ctx.fill();

                stats.eyePos -= stats.eyeVel;
                if (stats.eyePos < -1000) {
                    stats.eyeVel = -80;
                } else if (stats.eyePos > 1000) stats.eyePos = 1000;
            }


            ctx.restore();
        }

        function drawMouse() {
            ctx.beginPath();
            ctx.fillStyle = "#777";
            ctx.strokeStyle = "#ccc";
            
            //inner circle
            ctx.moveTo(mouse.x-8,mouse.y);
            ctx.lineTo(mouse.x-6,mouse.y-6);
            ctx.lineTo(mouse.x,mouse.y-8);
            ctx.lineTo(mouse.x+6,mouse.y-6);
            ctx.lineTo(mouse.x+8,mouse.y);
            ctx.lineTo(mouse.x+6,mouse.y+6);
            ctx.lineTo(mouse.x,mouse.y+8);
            ctx.lineTo(mouse.x-6,mouse.y+6);
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        }

        function calculateRoadPoints() {
            //calculates the 2d positions
            roadDrawPoints = [];

            road.forEach((road) => {
                const size = Math.hypot( road.size, road.size );// * (1 - 2*(road.pothole == true));

                const points = [];
                points.push( { x: road.x - size*Math.sin(road.angle + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI/4), road: road.road, final: road.final, finalPothole: road.finalPothole, finalOilslick: road.finalOilslick, finalMud: road.finalMud, finalBooster: road.finalBooster } );
                points.push( { x: road.x - size*Math.sin(road.angle + Math.PI/2 + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI/2 + Math.PI/4) } );
                points.push( { x: road.x - size*Math.sin(road.angle + Math.PI + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI + Math.PI/4) } );
                points.push( { x: road.x - size*Math.sin(road.angle + Math.PI*3/2 + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI*3/2 + Math.PI/4) } );

                roadDrawPoints.push(points);
            });
            if (currentRegion != "abyss" && currentRegion != "red carpet") road.forEach((roadItem, i) => {
                if (!road[i+1] || !road[i+3] || !roadItem.road || i%2 == 0) return;
                if (road[i].final ||  road[i+1].final) return;

                const diff = { x: road[i+1].x - roadItem.x, y: road[i+1].y - roadItem.y }

                const points = [];
                points.push( { x: roadItem.x, y: roadItem.y, stripe: true } );
                points.push( { x: roadItem.x + diff.x, y: roadItem.y + diff.y, stripe: true } );
                
                roadDrawPoints.push(points);
            });

            buildings.forEach((road) => {
                const size = Math.hypot( road.size, road.size );// * (1 - 2*(road.pothole == true));

                const point1 = { x: road.x - size*Math.sin(road.angle + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI/4) };
                const point1T = { x: road.x - size*Math.sin(road.angle + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI/4), top: true, color: road.color, size: road.height };
                const point2 = { x: road.x - size*Math.sin(road.angle + Math.PI/2 + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI/2 + Math.PI/4) };
                const point2T = { x: road.x - size*Math.sin(road.angle + Math.PI/2 + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI/2 + Math.PI/4), top: true, color: road.color, size: road.height };
                const point3 = { x: road.x - size*Math.sin(road.angle + Math.PI + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI + Math.PI/4) };
                const point3T = { x: road.x - size*Math.sin(road.angle + Math.PI + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI + Math.PI/4) , top: true, color: road.color, size: road.height };
                const point4 = { x: road.x - size*Math.sin(road.angle + Math.PI*3/2 + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI*3/2 + Math.PI/4) };
                const point4T = { x: road.x - size*Math.sin(road.angle + Math.PI*3/2 + Math.PI/4), y: road.y + size*Math.cos(road.angle + Math.PI*3/2 + Math.PI/4), top: true, color: road.color, size: road.height };

                buildingPoints.push( [point1T, point1, point2, point2T] );
                buildingPoints.push( [point2T, point2, point3, point3T] );
                buildingPoints.push( [point3T, point3, point4, point4T] );
                buildingPoints.push( [point4T, point4, point1, point1T] );
            });

            buildingPoints.forEach( (item) => {
                const diff = { x: item[0].x-item[1].x, y: item[0].y-item[1].y };

                item.push( {x: item[1].x+diff.x, y: item[1].y+diff.y} );
            });
        }

        function drawSkybox() {
            ctx.beginPath();

            linearGradient = ctx.createLinearGradient(0, -500+horizon, 0, 500+horizon);

            if (currentRegion == "highway") linearGradient.addColorStop(0.497, "#001133");
            else linearGradient.addColorStop(0.497, "#0099ff");
            if (currentRegion == "highway") linearGradient.addColorStop(0.503, "#111");
            else linearGradient.addColorStop(0.503, "#003300");

            ctx.fillStyle = linearGradient;

            if (currentRegion == "abyss") ctx.fillStyle = "#000";

            ctx.rect(-1000,-500,2000,1000);
            ctx.fill();

            // draw clouds
            if (currentRegion == "abyss") {
                ctx.beginPath();
                ctx.fillStyle = "#102";
                ctx.strokeStyle = "#203";
                let angleDiff;
                clouds.forEach((cloud) => {
                    angleDiff = car.angle-cloud.angle;

                    while (Math.abs(angleDiff-Math.PI*2) < Math.abs(angleDiff)) {
                        cloud.angle += Math.PI*2;
                        angleDiff = car.angle-cloud.angle;
                    }
                    while (Math.abs(angleDiff+Math.PI*2) < Math.abs(angleDiff)) {
                        cloud.angle -= Math.PI*2;
                        angleDiff = car.angle-cloud.angle;
                    }

                    ctx.moveTo(-angleDiff*2000+cloud.size, -2000);
                    ctx.lineTo(-angleDiff*2000+cloud.size, cloud.y/2+horizon);
                    ctx.lineTo(-angleDiff*2000, cloud.y/2+cloud.size+horizon);
                    ctx.lineTo(-angleDiff*2000-cloud.size, cloud.y/2+horizon);
                    ctx.moveTo(-angleDiff*2000-cloud.size, -2000);

                    ctx.moveTo(-angleDiff*2000+cloud.size, 2000);
                    ctx.lineTo(-angleDiff*2000+cloud.size, -cloud.y/2+horizon);
                    ctx.lineTo(-angleDiff*2000, -cloud.y/2-cloud.size+horizon);
                    ctx.lineTo(-angleDiff*2000-cloud.size, -cloud.y/2+horizon);
                    ctx.lineTo(-angleDiff*2000+cloud.size, 2000);
                })
            } else {
                ctx.beginPath();
                if (currentRegion == "highway") ctx.fillStyle = "#444";
                else ctx.fillStyle = "#999";
                ctx.strokeStyle = "#ccc";
                ctx.rect(-1000,-600,2000,200);
                let angleDiff;
                clouds.forEach((cloud) => {
                    angleDiff = car.angle-cloud.angle;

                    while (Math.abs(angleDiff-Math.PI*2) < Math.abs(angleDiff)) {
                        cloud.angle += Math.PI*2;
                        angleDiff = car.angle-cloud.angle;
                    }
                    while (Math.abs(angleDiff+Math.PI*2) < Math.abs(angleDiff)) {
                        cloud.angle -= Math.PI*2;
                        angleDiff = car.angle-cloud.angle;
                    }

                    ctx.moveTo(-angleDiff*2000+cloud.size, cloud.y);
                    ctx.lineTo(-angleDiff*2000+cloud.size*0.5, cloud.y+cloud.size*0.9);
                    ctx.lineTo(-angleDiff*2000, cloud.y+cloud.size);
                    ctx.lineTo(-angleDiff*2000-cloud.size*0.5, cloud.y+cloud.size*0.9);
                    ctx.lineTo(-angleDiff*2000-cloud.size, cloud.y);
                })
            }

            ctx.stroke();
            ctx.fill();
        }

        function drawRoadPerspective() {
            let roadColor = "#333";
            if (stats.slipRoad) roadColor = "#344";
            if (currentRegion == "abyss") roadColor = "#111";
            else if (currentRegion == "red carpet") roadColor = "#a11";

            ctx.save();

            ctx.beginPath();
            const angle = car.angle-Math.PI/2;
            let originalY,x,y;
            roadDrawPoints.forEach((points, pI) => {
                if (points[0].final) {
                    ctx.strokeStyle = "#666";
                    ctx.fillStyle = roadColor;
                    ctx.stroke();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = roadColor;
                    ctx.stroke();
                    ctx.fill();
                    ctx.lineWidth = game.defaultLineWidth;
            
                    ctx.beginPath();
                }

                if (Math.hypot(points[0].x-car.x, points[0].y-car.y) < 15000 || points[0].final || (points[0].road && pI%20 == 0)) points.forEach((point, i) => {

                    originalY = ((point.y-car.y) * Math.cos(angle) - (point.x-car.x) * Math.sin(angle))+400;
                    x = (point.x-car.x) * Math.cos(angle) + (point.y-car.y) * Math.sin(angle);

                    y = -calculateHorizonY(-originalY, -horizon);
                    x = ( ( y-horizon ) / 50 ) * x;

                    if (!points[0].final && Math.hypot(points[0].x-car.x, points[0].y-car.y) > 15000 && points[0].road && pI%20 == 0) {
                        if (i) return;
                        else ctx.lineTo(x,y);
                    }
                    
                    if (!i) ctx.moveTo( x, y );
                    else ctx.lineTo( x, y );

                    if (points[0].stripe && !i) ctx.lineWidth = Math.min(15,(y-horizon)/40);
                })
                ctx.closePath();

                if (points[0].final) {
                    ctx.fillStyle = "#393";
                    ctx.strokeStyle = "#393";
                    ctx.lineWidth = game.defaultLineWidth;
                    ctx.stroke();
                    ctx.fill();
            
                    ctx.beginPath();
                }

                if (points[0].finalPothole) {
                    ctx.fillStyle = "#111";
                    ctx.strokeStyle = "#666";
                    ctx.lineWidth = game.defaultLineWidth/3;
                    ctx.fill();
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
            
                    ctx.beginPath();
                }

                if (points[0].finalOilslick) {
                    ctx.fillStyle = "#00000099";
                    ctx.strokeStyle = "#111";
                    ctx.lineWidth = game.defaultLineWidth/3;
                    ctx.fill();
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
            
                    ctx.beginPath();
                }

                if (points[0].finalMud) {
                    ctx.fillStyle = "#532";
                    ctx.strokeStyle = "#321";
                    ctx.lineWidth = game.defaultLineWidth/3;
                    ctx.fill();
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
            
                    ctx.beginPath();
                }

                if (points[0].finalBooster) {
                    ctx.strokeStyle = "#fc3";
                    ctx.fillStyle = "#c93";
                    ctx.lineWidth = game.defaultLineWidth/3;
                    ctx.fill();
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
            
                    ctx.beginPath();
                }
                
                if (points[0].stripe) {

                    ctx.lineJoin = "miter";
                    ctx.strokeStyle = "#990";
                    ctx.stroke();
                    ctx.lineWidth = game.defaultLineWidth;
            
                    ctx.beginPath();
                }
            });

            buildingPoints.forEach((points, pI) => {
                ctx.beginPath();

                if (Math.hypot(points[0].x-car.x, points[0].y-car.y) < 15000) points.forEach((point, i) => { 
                    if (i === 4) return;
                    originalY = ((point.y-car.y) * Math.cos(angle) - (point.x-car.x) * Math.sin(angle))+400;
                    x = (point.x-car.x) * Math.cos(angle) + (point.y-car.y) * Math.sin(angle);

                    y = -calculateHorizonY(-originalY, -horizon);
                    x = ( ( y-horizon ) / 50 ) * x;
                    
                    if (Math.abs(y) > 6000) return;

                    if (point.top) {
                        ctx.lineTo( x, y );
                    } else {
                        ctx.lineTo( x, horizon - points[0].size*(y-horizon) );
                    }
                });
                ctx.closePath();

                ctx.strokeStyle = "#999";
                ctx.fillStyle = points[0].color;
                ctx.lineWidth = game.defaultLineWidth/3;
                ctx.stroke();
                ctx.fill();
                ctx.lineWidth = game.defaultLineWidth;
            });

            if (stats.fog) {
                ctx.fillStyle = fogGradient;
    
                ctx.fillRect(-1000,-500,3500,1000);
            }

            /*if (stats.wind) {
                let angleDiff = car.angle-stats.windAngle;

                while (Math.abs(angleDiff-Math.PI*2) < Math.abs(angleDiff)) {
                    stats.windAngle += Math.PI*2;
                    angleDiff = wheelAngle-mouseWheelAngle;
                }
                while (Math.abs(angleDiff+Math.PI*2) < Math.abs(angleDiff)) {
                    stats.windAngle -= Math.PI*2;
                    angleDiff = wheelAngle-mouseWheelAngle;
                }

                ctx.strokeStyle = "#ffffff55";
                ctx.moveTo(0,0);
                ctx.lineTo(angleDiff*100,0);
                ctx.stroke();
            }*/

            ctx.restore();
        }

        function calculateHorizonY(input, horizon) {
            if (input < -499) return horizon-100000/(1);
            return horizon-100000/(input+500);
        }

        function drive() {
            car.x += Math.cos(car.speedAngle)*car.speed;
            car.y += Math.sin(car.speedAngle)*car.speed;

            if ( car.running && ( keys.includes("w") || keys.includes(" ") ) && car.speed > -stats.topSpeed * ( 1 + 0.25 * !!(stats.noHands && mouse.selected != "wheel") ) * ( 1 + 0.5 * (car.booster/300) ) ) {
                car.speed -= stats.acceleration * (1 + 2*(car.speed > 0) ) * ( 1 + 1 * !!(stats.noHands && mouse.selected != "wheel") ) * ( 1 + 9 * (car.booster/300) );
            } else car.speed *= 0.999;
            if ( car.running && ( keys.includes("s") || keys.includes("shift") ) && car.speed < stats.topSpeed/5 && !stats.noBrake) {
                car.speed += stats.acceleration * (1 + 2*(car.speed < 0) );
            }

            if (mouse.selected == "wheel") {
                const wheelAngle = -car.wheel*Math.PI*5/2+Math.PI/2;
                let mouseWheelAngle = Math.atan( (mouse.y-250) / (mouse.x+200) ) + Math.PI*(mouse.x >= -200)-mouse.wheelOffset;

                let angleDiff = wheelAngle-mouseWheelAngle;

                while (Math.abs(angleDiff-Math.PI*2) < Math.abs(angleDiff)) {
                    mouseWheelAngle += Math.PI*2;
                    angleDiff = wheelAngle-mouseWheelAngle;
                }
                while (Math.abs(angleDiff+Math.PI*2) < Math.abs(angleDiff)) {
                    mouseWheelAngle -= Math.PI*2;
                    angleDiff = wheelAngle-mouseWheelAngle;
                }

                if (Math.abs(angleDiff) > stats.turnSpeed) angleDiff = Math.sign(angleDiff)*stats.turnSpeed;

                car.wheel -= -(angleDiff) / (Math.PI*5/2);
            } 
            else if (mouse.selected == "wiper") {
                const oldWiperAngle = -Math.PI*11/10*car.wiper+Math.PI/20;

                let diff = (mouse.x + 425 + 250 * (car.wiper))/250;

                diff = Math.max(-1/15,Math.min(1/15,diff));

                car.wiper -= diff;

                car.wiper = Math.max(0,Math.min(1,car.wiper));

                const wiperAngle = -Math.PI*11/10*car.wiper+Math.PI/20;

                let angle; 
                windshield = windshield.filter( (item) => {
                    angle = Math.atan( (item.y-300)/item.x )-Math.PI*(item.x < 0);
                    if (!item.x) angle = -Math.PI/2;
                    if ((angle > oldWiperAngle && angle < wiperAngle) || (angle < oldWiperAngle && angle > wiperAngle)) item.durability--;

                    if (item.durability <= 0) return false;
                    return true;
                } )
            }

            car.wheel = Math.max(-1,Math.min(1,car.wheel));

            car.angle += Math.PI/60/30 * car.wheel * car.speed * (1 - 0.5*car.oilslick);// * 1/(1+Math.abs(car.speed**2/30));
            car.angle = car.angle%(Math.PI*2);

            //changing speedAngle
            let angleDiff = car.angle-car.speedAngle;

            while (Math.abs(angleDiff-Math.PI*2) < Math.abs(angleDiff)) {
                car.speedAngle += Math.PI*2;
                angleDiff = car.angle-car.speedAngle;
            }
            while (Math.abs(angleDiff+Math.PI*2) < Math.abs(angleDiff)) {
                car.speedAngle -= Math.PI*2;
                angleDiff = car.angle-car.speedAngle;
            }

            if (stats.driftWiper && Math.sign(angleDiff) == -Math.sign(car.wiper-0.5)) {
                car.speedAngle += angleDiff
            } else {
                if (Math.abs(angleDiff) > Math.abs(stats.requiredDriftAngle/car.speed)) {
                    angleDiff *= stats.driftGrip;
                }

                car.speedAngle += angleDiff * (1-0.75*car.oilslick);
            }

            if (stats.wind) {
                let angleDiff = car.angle-stats.windAngle;

                car.angle += (Math.PI/300) * stats.windForce * Math.sin( angleDiff )/stats.inertia * Math.abs(Math.sin(game.timer/1000*Math.PI*2.12) * (0.5+0.5*Math.sin(game.timer/1000*Math.PI*10.3124)))/20 * car.speed;
            }

            if (car.pothole) {
                car.angle += car.pothole*Math.PI/1000 * car.speed;
            }

            if (car.booster > 0) car.booster--;
        }

        function checkCollision() {
            let mud = false;
            let touching = false;
            car.pothole = false;
            car.oilslick = false;

            let diffNeeded, diffNeededCos, carAngle, intAngle;
            
            road.forEach((road, i)=> {
                if (Math.hypot(road.x-car.x, road.y-car.y) > road.size*2) return;

                //road.angle --> angle to rectangle
                carAngle = Math.atan( (road.y-car.y) / (road.x-car.x) ) + Math.PI*(road.x > car.x);
                if (!(road.x-car.x)) carAngle = Math.PI*(road.x > car.x);
                intAngle = (carAngle-road.angle);

                diffNeeded = Math.abs(Math.sin(intAngle))**-1*road.size;
                diffNeededCos = Math.abs(Math.cos(intAngle))**-1*road.size;
                if (diffNeededCos < diffNeeded) diffNeeded = diffNeededCos;
                if (Math.hypot(road.x-car.x,road.y-car.y) < diffNeeded) {
                    if (road.oilslick) car.oilslick = true;
                    else if (road.booster) car.booster = 300;
                    else if (road.mud) mud = true;
                    else if (road.pothole) {
                        touching = false;

                        car.pothole = Math.sign(road.angle);
                    } else {
                        touching = true;
                    }

                    if (road.final) {
                        mouse.selected = false;
                        mouse.hover = false;

                        game.status = "choosing";

                        generateChoices();
                    }
                }
            })

            buildings.forEach((road, i)=> {
                if (Math.hypot(road.x-car.x, road.y-car.y) > road.size*2) return;

                //road.angle --> angle to rectangle
                carAngle = Math.atan( (road.y-car.y) / (road.x-car.x) ) + Math.PI*(road.x > car.x);
                if (!(road.x-car.x)) carAngle = Math.PI*(road.x > car.x);
                intAngle = (carAngle-road.angle);

                diffNeeded = Math.abs(Math.sin(intAngle))**-1*road.size;
                diffNeededCos = Math.abs(Math.cos(intAngle))**-1*road.size;
                if (diffNeededCos < diffNeeded) diffNeeded = diffNeededCos;
                if (Math.hypot(road.x-car.x,road.y-car.y) < diffNeeded) {
                    car.x -= Math.cos(car.speedAngle)*car.speed;
                    car.y -= Math.sin(car.speedAngle)*car.speed;

                    car.speed = 0;
                }
            })

            if (!touching && Math.abs(car.speed) > stats.offroadMaxSpeed && (!stats.offroadCruise || car.running)) {
                car.speed *= 1-stats.offroadSpeedLoss/stats.inertia;
            }

            if (mud && !car.mud) {
                for(var i = 0; i < 5; i++) windshield.push( { type: "mud", x: -550+1100*Math.random(), y: -300+550*Math.random(), durability: 3, maxDurability: 3 } )
            }
            car.mud = mud;

            if (car.mud && Math.abs(car.speed) > stats.offroadMaxSpeed && !(stats.offroadCruise && !stats.running)) {
                car.speed *= 1-0.15/stats.inertia;
            }
        }

        function drawDash() {
            //wipers & windsheild objects
            {
                const wiperAngle = -Math.PI*11/10*car.wiper+Math.PI/20;

                ctx.beginPath();
                ctx.moveTo(0,300);
                ctx.lineTo(Math.cos(wiperAngle)*800,300+Math.sin(wiperAngle)*800);
                ctx.closePath();
                ctx.strokeStyle = "#222";
                ctx.stroke();

                let size = 1;

                while (windshield.length > 200) windshield.splice(0,1);
                windshield.forEach( (item) => {
                    switch(item.type) {
                    case "mud": {
                        size = item.durability / item.maxDurability;

                        ctx.beginPath();
                        ctx.moveTo(item.x+450*size, item.y);
                        ctx.lineTo(item.x+450*size*0.7, item.y+450*size*0.7);
                        ctx.lineTo(item.x, item.y+450*size);
                        ctx.lineTo(item.x-450*size*0.7, item.y+450*size*0.7);
                        ctx.lineTo(item.x-450*size, item.y);
                        ctx.lineTo(item.x-450*size*0.7, item.y-450*size*0.7);
                        ctx.lineTo(item.x, item.y-450*size);
                        ctx.lineTo(item.x+450*size*0.7, item.y-450*size*0.7);
                        ctx.closePath();

                        ctx.fillStyle = "#532";
                        ctx.fill();
                        ctx.strokeStyle = "#321";
                        ctx.stroke();

                        break;
                        }
                    case "bug": {
                        size = item.durability / item.maxDurability;

                        ctx.beginPath();
                        ctx.moveTo(item.x+110*size, item.y);
                        ctx.lineTo(item.x+110*size*0.7, item.y+110*size*0.7);
                        ctx.lineTo(item.x, item.y+110*size);
                        ctx.lineTo(item.x-110*size*0.7, item.y+110*size*0.7);
                        ctx.lineTo(item.x-110*size, item.y);
                        ctx.lineTo(item.x-110*size*0.7, item.y-110*size*0.7);
                        ctx.lineTo(item.x, item.y-110*size);
                        ctx.lineTo(item.x+110*size*0.7, item.y-110*size*0.7);
                        ctx.closePath();

                        ctx.fillStyle = "#252";
                        ctx.fill();
                        ctx.strokeStyle = "#232";
                        ctx.stroke();

                        break;
                        }
                    }
                })
            }

            //windshield & dash
            {
                ctx.beginPath();
                linearGradient = ctx.createLinearGradient(0, -300, 0, 500);

                linearGradient.addColorStop(0, "#99ffff33");
                linearGradient.addColorStop(1, "#00aaff33");

                ctx.fillStyle = linearGradient;

                //ctx.fillStyle = "#9999ff22";
                ctx.rect(-1800,-500,3600,1000);
                ctx.fill();
            }
            
            //upgrades
            {
                ctx.beginPath();
                ctx.save();
                ctx.translate(-500,-375);
                ctx.scale(0.2,0.2);

                chosenPunish.forEach( (thing) => {
                    ctx.beginPath();
                    ctx.rect(25,-500,-50,500);
                    ctx.moveTo(-140,0);
                    ctx.lineTo(-100,100);
                    ctx.lineTo(0,140);
                    ctx.lineTo(100,100);
                    ctx.lineTo(140,0);
                    ctx.lineTo(100,-100);
                    ctx.lineTo(0,-140);
                    ctx.lineTo(-100,-100);
                    ctx.closePath();

                    ctx.fillStyle = "#777";
                    ctx.strokeStyle = "#ccc";

                    ctx.stroke();
                    ctx.fill();

                    thing.drawFunction(true);

                    ctx.translate(-300,50);
                })

                ctx.restore();
                ctx.save();
                ctx.translate(500,-375);
                ctx.scale(0.2,0.2)
                
                chosenPerk.forEach( (thing) => {
                    ctx.beginPath();
                    ctx.rect(25,-500,-50,500);
                    ctx.moveTo(-140,0);
                    ctx.lineTo(-100,100);
                    ctx.lineTo(0,140);
                    ctx.lineTo(100,100);
                    ctx.lineTo(140,0);
                    ctx.lineTo(100,-100);
                    ctx.lineTo(0,-140);
                    ctx.lineTo(-100,-100);
                    ctx.closePath();

                    ctx.fillStyle = "#777";
                    ctx.strokeStyle = "#ccc";

                    ctx.stroke();
                    ctx.fill();

                    thing.drawFunction(true);

                    ctx.translate(450,87.5);
                })

                ctx.restore();
            }

            //dash
            {
                ctx.beginPath();
                ctx.strokeStyle = "#222";
                ctx.fillStyle = "#664e3a";
                ctx.moveTo(-2000, 800);
                ctx.lineTo(-700, 300);
                ctx.lineTo(-300, 200);
                ctx.lineTo(300, 200);
                ctx.lineTo(700, 300);
                ctx.lineTo(2000, 800);
                ctx.lineTo(2000, 1000);
                ctx.lineTo(-2000, 1000);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(-1000, -300);
                ctx.lineTo(-700, -400);
                ctx.lineTo(-200, -475);
                ctx.lineTo(200, -475);
                ctx.lineTo(700, -400);
                ctx.lineTo(1000, -300);
                ctx.lineTo(1000, -1000);
                ctx.lineTo(-1000, -1000);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            }

            //spedometer
            {
                ctx.save();
                
                ctx.translate(70,280);

                ctx.beginPath();
                ctx.arc(0,0,50,-Math.PI*5/4,Math.PI/4);
                ctx.lineTo(15,25);
                ctx.lineTo(-15,25);
                ctx.closePath();
                
                ctx.strokeStyle = "#222";
                ctx.fillStyle = "#444";
                ctx.fill();
                ctx.stroke();

                ctx.strokeStyle = "#a00";

                const speedAngle = -Math.PI*4.75/4 + Math.abs(car.speed)/100*Math.PI*5.5/4;

                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.lineTo(Math.cos(speedAngle)*35, Math.sin(speedAngle)*35);

                ctx.stroke();

                ctx.restore();
            }

            //ignition
            {
                ctx.save();
                
                ctx.translate(70,350);

                ctx.beginPath();
                ctx.arc(0,0,25,0,Math.PI*2);
                
                if (car.running) ctx.fillStyle = "#292";
                else ctx.fillStyle = "#922";
                ctx.fill();
                ctx.strokeStyle = "#222";
                if (mouse.selected == "ignition") ctx.strokeStyle = "#666";
                else if (mouse.hover == "ignition") ctx.strokeStyle = "#444";
                ctx.stroke();

                ctx.beginPath();

                ctx.moveTo(-10*(1-2*car.running),-10);
                ctx.lineTo(10*(1-2*car.running),10);

                ctx.strokeStyle = "#666";
                if (mouse.selected == "ignition") ctx.strokeStyle = "#ccc";
                else if (mouse.hover == "ignition") ctx.strokeStyle = "#999";
                ctx.stroke();

                ctx.restore();
            }

            //wiper control
            {
                ctx.beginPath();
                ctx.rect(-700,400,300,30);
                ctx.fillStyle = "#444";
                ctx.fill();
                ctx.strokeStyle = "#222";
                ctx.stroke();
                ctx.beginPath();
                //-485 & -735
                ctx.rect(-435 - 250 * (car.wiper), 390, 20, 50);
                ctx.fillStyle = "#444";
                ctx.fill();
                ctx.strokeStyle = "#222";
                if (mouse.selected == "wiper") ctx.strokeStyle = "#999";
                else if (mouse.hover == "wiper") ctx.strokeStyle = "#666";
                ctx.stroke();

                //drawLine
                if (mouse.selected == "wiper") {
                    ctx.strokeStyle = "#ffffff66";
                    ctx.beginPath();
                    ctx.moveTo(mouse.x, mouse.y);
                    ctx.lineTo(-425 - 250 * (car.wiper), 415);
                    ctx.stroke();
                }
            }

            //fps gauge
            {
                ctx.beginPath();

                ctx.rect(-325,300, 50, 30);

                ctx.strokeStyle = "#222";
                ctx.fillStyle = "#444";
                ctx.stroke();
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = "#777";
                ctx.fillStyle = "#999";
                ctx.font = "20px Jura";
                ctx.fillText(game.fps, -300,315);
            }

            //wheel
            {
                ctx.save();
                ctx.translate(-200, 250);
                ctx.rotate(-car.wheel*Math.PI*5/2);

                ctx.strokeStyle = "#333";
                if (mouse.selected == "wheel") ctx.strokeStyle = "#fff";
                else if (mouse.hover == "wheel") ctx.strokeStyle = "#888";
                ctx.fillStyle = "#ad7d53";
                ctx.beginPath();
                ctx.arc(0,0,200,0,Math.PI*2);
                ctx.moveTo(-180,0);
                ctx.arc(0,0,180,0,Math.PI*2, true);
                ctx.rect(-190,-10,380,20);
                ctx.rect(-10,0,20,190);
                ctx.stroke();
                ctx.fill();
                
                ctx.strokeStyle = "#333";
                if (mouse.selected == "horn") ctx.strokeStyle = "#fff";
                else if (mouse.hover == "horn") ctx.strokeStyle = "#888";
                ctx.beginPath();
                ctx.moveTo(-50,-20);
                ctx.lineTo(-30,-40);
                ctx.lineTo(30,-40);
                ctx.lineTo(50,-20);
                ctx.lineTo(50,30);
                ctx.lineTo(30,50);
                ctx.lineTo(-30,50);
                ctx.lineTo(-50,30);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();

                ctx.restore();

                //drawLine
                if (mouse.selected == "wheel") {
                    ctx.strokeStyle = "#ffffff66";
                    ctx.beginPath();
                    ctx.moveTo(mouse.x, mouse.y);
                    ctx.lineTo(-200 + Math.cos(-car.wheel*Math.PI*5/2-Math.PI/2+mouse.wheelOffset)*190, 250 + Math.sin(-car.wheel*Math.PI*5/2-Math.PI/2+mouse.wheelOffset)*190);
                    ctx.stroke();
                }
            }
        
            //region name
            {
                ctx.beginPath();
                ctx.strokeStyle = "#222";
                ctx.fillStyle = "#666";
                ctx.font = "50px Jura";
                ctx.strokeText(currentRegion.toUpperCase(), 600, -475);
                ctx.fillText(currentRegion.toUpperCase(), 600, -475);
            } 
        }

        function drawTimer() {
            ctx.beginPath();

            ctx.strokeStyle = "#ccc";
            ctx.fillStyle = "#33333399";

            //ctx.fillStyle = "#9999ff22";
            ctx.rect(-450,-475,900,140);
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-400, -375);
            ctx.lineTo(400, -375);
            ctx.strokeStyle = "#555";
            ctx.lineWidth = 50;
            ctx.stroke();
            ctx.strokeStyle = "#888";
            ctx.lineWidth = 35;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-400, -375);
            ctx.lineTo(-399 + 799*Math.min(1, game.timer/stats.timerMax), -375);
            ctx.strokeStyle = "#393";
            if (game.timer > stats.timerMax && (game.timer/15)%2 < 1) ctx.strokeStyle = "#f33";
            else if (game.timer > stats.timerMax*7/8) ctx.strokeStyle = "#933";
            else if (game.timer > stats.timerMax*3/4) ctx.strokeStyle = "#993";
            ctx.lineWidth = 35;
            ctx.stroke();

            ctx.lineWidth = game.defaultLineWidth;

            //draw the current to be upgrade
            ctx.save();

            ctx.lineWidth = 3;

            ctx.translate(-375,-430);
            if (currentRegion == "red carpet") ctx.translate(375,0);

            ctx.beginPath();
            ctx.strokeStyle = "#777";
            if (perkChoicePos == 0) ctx.strokeStyle = "#ccc";
            ctx.fillStyle = "#ffffff22";
            
            for (var i = 0; i < perkChoices.length; i++) {
                ctx.moveTo(20,0);
                ctx.lineTo(15,15);
                ctx.lineTo(0,20);
                ctx.lineTo(-15,15);
                ctx.lineTo(-20,0);
                ctx.lineTo(-15,-15);
                ctx.lineTo(0,-20);
                ctx.lineTo(15,-15);
                ctx.closePath();

                if (i == perkChoicePos) {
                    ctx.moveTo(25,0);
                    ctx.lineTo(20,20);
                    ctx.lineTo(0,25);
                    ctx.lineTo(-20,20);
                    ctx.lineTo(-25,0);
                    ctx.lineTo(-20,-20);
                    ctx.lineTo(0,-25);
                    ctx.lineTo(20,-20);
                    ctx.closePath();
                }

                switch(perkChoices[i]) {
                    case "perk": {
                        ctx.moveTo(-10, -3);
                        ctx.lineTo(-3, -3);
                        ctx.lineTo(-3, -10);
                        ctx.lineTo(3, -10);
                        ctx.lineTo(3, -3);
                        ctx.lineTo(10, -3);
                        ctx.lineTo(10, 3);
                        ctx.lineTo(3, 3);
                        ctx.lineTo(3, 10);
                        ctx.lineTo(-3, 10);
                        ctx.lineTo(-3, 3);
                        ctx.lineTo(-10, 3);
                        ctx.closePath();

                        break;
                    }
                    case "punish": {
                        ctx.moveTo(-10, -3);
                        ctx.lineTo(10, -3);
                        ctx.lineTo(10, 3);
                        ctx.lineTo(-10, 3);
                        ctx.closePath();

                        break;
                    }
                    case "unstackPerk": {
                        ctx.translate(-7,7);
                        
                        ctx.moveTo(-10, -3);
                        ctx.lineTo(-3, -3);
                        ctx.lineTo(-3, -10);
                        ctx.lineTo(3, -10);
                        ctx.lineTo(3, -3);
                        ctx.lineTo(10, -3);
                        ctx.lineTo(10, 3);
                        ctx.lineTo(3, 3);
                        ctx.lineTo(3, 10);
                        ctx.lineTo(-3, 10);
                        ctx.lineTo(-3, 3);
                        ctx.lineTo(-10, 3);
                        ctx.closePath();

                        ctx.translate(14,-14);
                        
                        ctx.moveTo(-10, -3);
                        ctx.lineTo(-3, -3);
                        ctx.lineTo(-3, -10);
                        ctx.lineTo(3, -10);
                        ctx.lineTo(3, -3);
                        ctx.lineTo(10, -3);
                        ctx.lineTo(10, 3);
                        ctx.lineTo(3, 3);
                        ctx.lineTo(3, 10);
                        ctx.lineTo(-3, 10);
                        ctx.lineTo(-3, 3);
                        ctx.lineTo(-10, 3);
                        ctx.closePath();
                        
                        ctx.translate(-7,7);

                        break;
                    }
                    case "unstackPunish": {
                        ctx.translate(-7,7);

                        ctx.moveTo(-10, -3);
                        ctx.lineTo(10, -3);
                        ctx.lineTo(10, 3);
                        ctx.lineTo(-10, 3);
                        ctx.closePath();

                        ctx.translate(14,-14);
                        
                        ctx.moveTo(-10, -3);
                        ctx.lineTo(10, -3);
                        ctx.lineTo(10, 3);
                        ctx.lineTo(-10, 3);
                        ctx.closePath();
                        
                        ctx.translate(-7,7);

                        break;
                    }
                    case "final": {
                        ctx.fill();
                        ctx.stroke();

                        ctx.beginPath();
                        
                        ctx.moveTo(0, -13);
                        ctx.lineTo(8, 10);
                        ctx.lineTo(-11, -5);
                        ctx.lineTo(11, -5);
                        ctx.lineTo(-8, 10);
                        ctx.closePath();
                        
                        ctx.fillStyle = "#ccc";

                        ctx.fill();
                        ctx.stroke();

                        break;
                    }
                    case "finish": {
                        ctx.fill();
                        ctx.stroke();

                        ctx.beginPath();
                        
                        ctx.moveTo(0, -13);
                        ctx.lineTo(8, 10);
                        ctx.lineTo(-11, -5);
                        ctx.lineTo(11, -5);
                        ctx.lineTo(-8, 10);
                        ctx.closePath();
                        
                        ctx.fillStyle = "#ccc";

                        ctx.fill();
                        ctx.stroke();

                        break;
                    }
                }

                ctx.closePath();

                if (i == perkChoicePos-1) {
                    ctx.fill();
                    ctx.stroke();

                    ctx.strokeStyle = "#ccc";
                    ctx.beginPath();
                }

                ctx.translate(50,0);
            }

            ctx.fill();
            ctx.stroke();

            ctx.restore();

            ctx.beginPath();

            ctx.save();

            ctx.translate(-375,-430);
            ctx.scale(0.2,0.2);
            for (var i = 0; i < chosenPerkDraw.length; i++) {
                chosenPerkDraw[i](true);

                ctx.translate(250,0);
            }

            ctx.restore();
        }

        function checkHover() {
            //wheel
            const wheelHypot = Math.hypot(mouse.x+200, mouse.y-250);
            if (wheelHypot > 150 && wheelHypot < 230) {
                mouse.hover = "wheel";
                return;
            } else if (wheelHypot < 75) {
                mouse.hover = "horn";
                return;
            } else if (Math.hypot(mouse.x-70, mouse.y-350) < 50) {
                mouse.hover = "ignition";
                return;
            } else if (Math.hypot(mouse.x+425 + 250 * (car.wiper), mouse.y-415) < 50) {
                mouse.hover = "wiper";
                return;
            }

            mouse.hover = false;
        }

        function drawChoices() {
            ctx.beginPath();
            ctx.fillStyle = "#ffffff33";
            ctx.strokeStyle = "#99999999";
            ctx.rect(-1000,-1000,3500,3600);
            ctx.fill();

            if (perkChoices[perkChoicePos] == "final" || perkChoicePos == perkChoices.length) {
                ctx.fillStyle = "#f33";
                ctx.font = "100px serif";
                ctx.fillText("R    E    M    O    V    E", 0, -250);
            } else {
                ctx.fillStyle = "#fff";
                ctx.font = "100px serif";
                ctx.fillText("C    H    O    O    S    E", 0, -250);
            }
            
            choices.forEach((choice, i) => {
                ctx.beginPath();

                if (mouse.x > -600+800*i && mouse.x < -200+800*i && mouse.y > -200 && mouse.y < 200) {
                    ctx.strokeStyle = "#ccc";
                    ctx.rect(-620+800*i, -220, 440, 440);
                } else {
                    ctx.strokeStyle = "#999";
                    ctx.rect(-600+800*i, -200, 400, 400);
                }
                ctx.strokeStyle = "#ccc";
                ctx.fillStyle = "#ffffff33";
                ctx.fill();
                ctx.stroke();

                ctx.save();

                ctx.translate(-400+800*i, 0);

                choice.choice.drawFunction();

                ctx.restore();
                
                if (mouse.x > -600+800*i && mouse.x < -200+800*i && mouse.y > -200 && mouse.y < 200) {
                    ctx.beginPath();
                    ctx.rect(mouse.x-choice.choice.desc.length*12.5, mouse.y+50, choice.choice.desc.length*25, 100);
                    ctx.fillStyle = "#ffffff55";
                    ctx.strokeStyle = "#ccc";
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.fillStyle = "#555";
                    ctx.font = "50px serif";
                    ctx.fillText(choice.choice.desc, mouse.x, mouse.y+100);
                }
            });
        }

        function generateChoices() {
            choices = [];

            const positions = [];

            if (perkChoices[perkChoicePos] == "perk") for (var i = 0; i < 2 && i < stackablePerks.length; i++) {
                let position = Math.round((stackablePerks.length - 1)*Math.random());
                while (positions.includes(position)) position = Math.round((stackablePerks.length - 1)*Math.random());
                let perk = stackablePerks[position];

                positions.push(position);

                choices.push({choice: perk, position: position})
            }

            else if (perkChoices[perkChoicePos] == "punish") for (var i = 0; i < 2 && i < stackablePunishments.length; i++) {
                let position = Math.round((stackablePunishments.length - 1)*Math.random());
                while (positions.includes(position)) position = Math.round((stackablePunishments.length - 1)*Math.random());
                let punishment = stackablePunishments[position];

                positions.push(position);

                choices.push({choice: punishment, position: position})
            }

            else if (perkChoices[perkChoicePos] == "unstackPerk") for (var i = 0; i < 2 && i < unStackablePerks.length; i++) {
                let position = Math.round((unStackablePerks.length - 1)*Math.random());
                while (positions.includes(position)) position = Math.round((unStackablePerks.length - 1)*Math.random());
                let perk = unStackablePerks[position];

                positions.push(position);

                choices.push({choice: perk, position: position})
            }

            else if (perkChoices[perkChoicePos] == "unstackPunish") for (var i = 0; i < 2 && i < unStackablePunishments.length; i++) {
                let position = Math.round((unStackablePunishments.length - 1)*Math.random());
                while (positions.includes(position)) position = Math.round((unStackablePunishments.length - 1)*Math.random());
                let punishment = unStackablePunishments[position];

                positions.push(position);

                choices.push({choice: punishment, position: position})
            }
            else if (perkChoices[perkChoicePos] == "final") for (var i = 0; i < 2 && i < chosenPunish.length; i++) {
                let position = Math.round((chosenPunish.length - 1)*Math.random());
                while (positions.includes(position)) position = Math.round((chosenPunish.length - 1)*Math.random());
                let punishment = chosenPunish[position];

                positions.push(position);

                choices.push({choice: punishment, position: position})
            }
            else if (perkChoicePos == perkChoices.length) for (var i = 0; i < 2 && i < chosenPerk.length; i++) {
                let position = Math.round((chosenPerk.length - 1)*Math.random());
                while (positions.includes(position)) position = Math.round((chosenPerk.length - 1)*Math.random());
                let punishment = chosenPerk[position];

                positions.push(position);

                choices.push({choice: punishment, position: position})
            }
        }

        function chooseChoice() {
            let choiceNum = false;
            if (mouse.x > -600 && mouse.x < -200 && mouse.y > -200 && mouse.y < 200) {
                choiceNum = 0;
            }
            if (mouse.x > -200 && mouse.x < 600 && mouse.y > -200 && mouse.y < 200) {
                choiceNum = 1;
            }

            if (choiceNum !== false) {
                const choice = choices[choiceNum];

                choice.choice.chooseFunction();

                if (perkChoices[perkChoicePos] == "unstackPerk") {
                    chosenPerk.push(choice.choice);
                    unStackablePerks.splice(choice.position, 1);
                }
                else if (perkChoices[perkChoicePos] == "unstackPunish") {
                    chosenPunish.push(choice.choice);
                    unStackablePunishments.splice(choice.position, 1);
                } else if (perkChoices[perkChoicePos] == "final") {
                    chosenPunish.splice(choice.position, 1);

                    perkChoicePos++;
                    generateChoices();

                    return;
                }

                chosenPerkDraw.push(choice.choice.drawFunction);

                car.x = 0;
                car.y = 0;
                car.speed = 0;
                car.angle = Math.PI/2;
                car.speedAngle = Math.PI/2;
                car.running = false;

                game.status = "driving";

                game.timer = 0;
                game.timerCounting = false;
                stats.timerMax *= 0.985;

                
                if (perkChoicePos == perkChoices.length) {
                    chosenPerk.splice(choice.position, 1);

                    currentRegion = regions[0];
                    regions.splice(0,1);

                    perkChoicePos = 0;
                    chosenPerkDraw = [];

                    stats = {
                        roadLength: 80000,
                        roadSize: 200,
                        roadAngle: Math.PI/20,
                        acceleration: 0.05,
                        topSpeed: 30,
                        turnSpeed: Math.PI/25,
                        offroadSpeedLoss: 0.2,
                        offroadMaxSpeed: 8,
                        requiredDriftAngle: Math.PI/17,
                        driftGrip: 0.07,
                        inertia: 1,
                        roadHazardChance: 1,
                        timerMax: 4000,
                    }

                    if (currentRegion == "city") stats.roadSize *= 1.25;
                    else if (currentRegion == "abyss") {
                        stats.roadSize *= 0.90;
                        stats.roadLength /= 2.2;

                        song.src = 'The Fallen.mp3';
                        song.play();
                    }
                    else if (currentRegion == "highway") {
                        stats.roadSize *= 1.9;
                        stats.roadLength *= 2;
                        stats.roadAngle *= 0.5;
                        stats.topSpeed *= 2;
                        stats.acceleration *= 2;

                        song.src = 'TraffStick.ogg';
                        song.play();
                    }
                    else if (currentRegion == "red carpet") {
                        stats.roadLength *= 2.5;
                        stats.timerMax *= 2.75;

                        perkChoices = [ "finish" ];
                    }

                    chosenPerk.forEach((thing) => thing.chooseFunction());
                    chosenPunish.forEach((thing) => thing.chooseFunction());
                } else {
                    perkChoicePos++;

                    //generateChoices();
                    //game.status = "choosing"
                }

                if (stats.wind) stats.windAngle = Math.PI*2*Math.random();

                generatePlatformRoad(stats.roadLength/stats.roadSize);
            }
        }

        function generatePlatformRoad(amount) {
            road = [];
            buildings = [];
            buildingPoints = [];

            let pos = { x: 0, y: 0};
            let angle = -Math.PI/2;
            let size = stats.roadSize;

            for (var i = 0; i <= Math.floor(amount); i++) {
                let roadAngle = Math.PI*Math.random();
                if (currentRegion == "city" || currentRegion == "red carpet") roadAngle = angle;
                road.push( {x: pos.x, y: pos.y, size: size+size*Math.random()/2*(currentRegion != "city" && currentRegion != "red carpet") + size/4*(currentRegion == "city" || currentRegion == "red carpet"), angle: roadAngle, road: true, final: i == Math.floor(amount), roadAngle: angle} );

                pos.x += Math.cos(angle)*size * (1 + 1.2 * (currentRegion == "abyss"));
                pos.y += Math.sin(angle)*size * (1 + 1.2 * (currentRegion == "abyss"));

                if (currentRegion == "city") { if (Math.random() < stats.roadAngle/Math.PI/7) angle += Math.PI/2-Math.PI*(Math.random() < 0.5)
                } else angle += stats.roadAngle/2-stats.roadAngle*Math.random();
            }

            if (stats.potholes) {
                road.forEach((roadItem, i) => {if (roadItem.road && (Math.random() < 0.10*stats.roadHazardChance) && i <= road.length-3) {
                    road.push( {x: roadItem.x - roadItem.size + roadItem.size*2*Math.random(), y: roadItem.y - roadItem.size + roadItem.size*2*Math.random(), size: roadItem.size/5, angle: Math.PI*Math.random()-Math.PI/2, pothole: true } );
                } } );
                road[road.length-1].finalPothole = true
            }
            if (stats.oilslick) {
                road.forEach((roadItem, i) => {if (roadItem.road && (Math.random() < 0.05*stats.roadHazardChance) && i <= road.length-3) {
                    road.push( {x: roadItem.x - roadItem.size + roadItem.size*2*Math.random(), y: roadItem.y - roadItem.size + roadItem.size*Math.random(), size: roadItem.size*3, angle: Math.PI*Math.random()-Math.PI/2, oilslick: true } );
                } } );
                road[road.length-1].finalOilslick = true
            }
            if (stats.mud) {
                road.forEach((roadItem, i) => {if (roadItem.road && (Math.random() < 0.020*stats.roadHazardChance) && i <= road.length-3) {
                    road.push( {x: roadItem.x - roadItem.size + roadItem.size*2*Math.random(), y: roadItem.y - roadItem.size + roadItem.size*Math.random(), size: roadItem.size*0.6, angle: Math.PI*Math.random()-Math.PI/2, mud: true } );
                } } );
                road[road.length-1].finalMud = true
            }
            if (stats.booster) {
                road.forEach((roadItem, i) => {if (roadItem.road && (Math.random() < 0.010*stats.roadHazardChance) && i <= road.length-3) {
                    road.push( {x: roadItem.x - roadItem.size + roadItem.size*2*Math.random(), y: roadItem.y - roadItem.size + roadItem.size*Math.random(), size: roadItem.size*0.2, angle: Math.PI*Math.random()-Math.PI/2, booster: true } );
                } } );
                road[road.length-1].finalBooster = true
            }
            if (currentRegion == "city") {

                road.forEach((roadItem, i) => {if (roadItem.road && (Math.random() < 1*stats.roadHazardChance) && i <= road.length-3) {
                    const angle = roadItem.roadAngle+Math.PI/2 + Math.PI*(Math.random() < 0.5);
                    buildings.push( {x: roadItem.x - roadItem.size*4*Math.cos(angle), y: roadItem.y - roadItem.size*4*Math.sin(angle), size: roadItem.size, angle: roadItem.roadAngle, color: ("#" + Math.floor(Math.random()*9) + Math.floor(Math.random()*9) + Math.floor(Math.random()*9)), height: 3 + 5*Math.random() } );
                    i += 3;
                } } );

                buildings = buildings.filter((building, i) => {
                    let thing = true
                    road.forEach( (road) => {if ( Math.hypot(road.x-building.x, road.y-building.y) < building.size*2.5 ) thing = false; } )
                    buildings.forEach( (road, i2) => {if ( i != i2) if (Math.hypot(road.x-building.x, road.y-building.y) < building.size + road.size && (road.exist || i2 > i) ) thing = false; } )

                    building.exist = thing;

                    return thing;
                })
            }

            calculateRoadPoints();
        }
    </script>
    <script type>
        //music handling
        let song = new Audio('PlaStick.ogg');
        song.loop = true;
        let engineRev = new Audio('Engine Rev.ogg');
        engineRev.loop = true;
        engineRev.volume = 0.1;

        const check = () => {
            if (mouse.down) {
                song.play();
                engineRev.play();
            } else {
                setTimeout(check, 100);
            }
        };
        check();

        //update rev
        setInterval(() => {
            if (game.status == "driving") engineRev.volume = 0.1;
            else engineRev.volume = 0;
            engineRev.playbackRate = 1 - car.speed/30;
            song.volume = 0.6;
        },100)

        if (1) {
            generatePlatformRoad(stats.roadLength/stats.roadSize)

            if (navigator.userAgent.toLowerCase().includes("firefox")) startAnimating(60);
            else setInterval( () => { tickloop() }, 16.66);
        } else setInterval( () => {
            drawSkybox();
            drawDash();

            ctx.beginPath();
            ctx.fillStyle = "#ffffff33";
            ctx.rect(-1000,-1000,3500,3600);
            ctx.fill();
            ctx.beginPath();
            ctx.strokeStyle = "#999";
            ctx.rect(-200, -200, 400, 400);
            ctx.fill();
            ctx.stroke();
            
            generatePlatformRoad(stats.roadLength/stats.roadSize);

            stackablePunishments[6].drawFunction()
        },100)
    </script>
</body>
</html>
